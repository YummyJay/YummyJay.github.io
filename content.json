{"meta":{"title":"YummyJay's archives","subtitle":null,"description":null,"author":"YummyJay","url":"https://YummyJay.github.io"},"pages":[{"title":"about","date":"2016-10-09T01:55:32.000Z","updated":"2016-10-20T11:51:34.446Z","comments":true,"path":"about/index.html","permalink":"https://YummyJay.github.io/about/index.html","excerpt":"","text":"浙江蒟蒻一只。。。"},{"title":"tags","date":"2016-10-09T01:52:27.000Z","updated":"2016-10-09T01:54:03.500Z","comments":true,"path":"tags/index.html","permalink":"https://YummyJay.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-10-09T01:54:39.000Z","updated":"2016-10-09T01:55:05.286Z","comments":true,"path":"categories/index.html","permalink":"https://YummyJay.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"POI2008 Lights","slug":"POI2008 Lights","date":"2016-10-27T11:30:55.000Z","updated":"2016-10-27T12:03:55.516Z","comments":true,"path":"2016/10/27/POI2008 Lights/","link":"","permalink":"https://YummyJay.github.io/2016/10/27/POI2008 Lights/","excerpt":"POI2008 Lights","text":"POI2008 Lights 题目大意：对于一个长度为n的数列p，数列中任意两个数字都互质，准备一个无限长的储存器，然后从p1开始，把储存器中p1的倍数位置都赋值为p1，把储存器中p2的倍数位置都赋值为p2，把储存器中p3……把储存器中pn的倍数全都赋值为pn。求最后每一个pi在储存器中出现的比例。用分数表示。 题解：由于后面的数会把前面的数覆盖掉，我们不妨从后往前算： 很容易得到： $$ ans _i = ( 1- \\sum _ {j=i+1}^n ans _ j ) \\times \\frac 1 {p _i}$$ 经过化简，可以得到一个递推式： $$ ans _i = ans _ {i+1} \\times \\frac {p _{i+1}-1} {p _i}$$ 这样就可以轻松的得到答案了。 数据范围非常大，我们要使用高精度算法。 但我们发现，我们不能直接写高精乘法、高精度的gcd以及高精除法。 因为显然会TLE。我们发现我们只需要求一个高精度数与一个低精度数之间的运算。 如此一来，题目即可解。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int N=1005;struct BigInt&#123; static const int BASE=(int)1e9; ll num[N],len; BigInt()&#123; len=1; memset(num,0,sizeof(num)); &#125; void maintain() &#123; len=N; while(len-1&gt;=1&amp;&amp;!num[len-1])len--; &#125; BigInt&amp; operator = (const int &amp;tmp)&#123; len=1,num[0]=tmp; return *this; &#125; bool operator ==(const int &amp;tmp)const&#123; if(len==1&amp;&amp;num[0]==tmp)return true; return false; &#125; BigInt&amp; operator *= (const int &amp;tmp)&#123; for(int i=0;i&lt;len;i++) num[i]=num[i]*tmp; for(int i=0;i&lt;len;i++)&#123; if(num[i]&gt;=BASE)&#123; num[i+1]+=num[i]/BASE; num[i]%=BASE; &#125; &#125; if(num[len])len++; return *this; &#125; BigInt&amp; operator /= (const int &amp;tmp)&#123; ll rest=0; for(int i=len-1;i&gt;=0;i--)&#123; num[i]+=rest*BASE; rest=num[i]%tmp; num[i]/=tmp; &#125; maintain(); return *this; &#125; BigInt operator - (const BigInt &amp;tmp)const&#123; BigInt res; res.len=len; for(int i=0;i&lt;len;i++)&#123; res.num[i]=num[i]-tmp.num[i]; if(res.num[i]&lt;0)&#123; res.num[i+1]--; res.num[i]+=BASE; &#125; &#125; res.maintain(); return res; &#125; int operator % (const int &amp;tmp)const&#123; BigInt t=*this; t/=tmp; t*=tmp; t=*this-t; return t.num[0]; &#125; void Print()&#123; printf(\"%d\",num[len-1]); for(int i=len-2;i&gt;=0;i--)printf(\"%09d\",num[i]); &#125;&#125;son,mom;int gcd(int a,int b)&#123; if(b==0)return a; return gcd(b,a%b);&#125;struct Frac&#123; BigInt son,mom; void Print()&#123; son.Print(); putchar('/'); mom.Print(); putchar('\\n'); &#125; Frac operator * (const Frac &amp;tmp)const&#123; Frac res=(Frac)&#123;son,mom&#125;; int tson=tmp.son.num[0],tmom=tmp.mom.num[0],a,b; a=gcd(tmom,res.son%tmom); b=gcd(tson,res.mom%tson); res.son*=tson,res.mom*=tmom; res.son/=a,res.son/=b; res.mom/=a,res.mom/=b; return res; &#125;&#125;ans[N];int n,p[N];int main()&#123; scanf(\"%d\",&amp;n); for(int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;p[i]); son=1,mom=p[n]; ans[n]=(Frac)&#123;son,mom&#125;; for(int i=n-1;i&gt;=1;i--)&#123; son=p[i+1]-1,mom=p[i]; if(son==0||ans[i+1].son==0)&#123; son=0,mom=1; ans[i]=(Frac)&#123;son,mom&#125;; &#125;else&#123; int g=gcd(p[i+1]-1,p[i]); son/=g,mom/=g; ans[i]=ans[i+1]*(Frac)&#123;son,mom&#125;; &#125; &#125; for(int i=1;i&lt;=n;i++)ans[i].Print(); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"高精度","slug":"高精度","permalink":"https://YummyJay.github.io/tags/高精度/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2008 The Great Escape","slug":"POI2008 The Great Escape","date":"2016-10-25T13:23:00.000Z","updated":"2016-10-25T14:40:58.703Z","comments":true,"path":"2016/10/25/POI2008 The Great Escape/","link":"","permalink":"https://YummyJay.github.io/2016/10/25/POI2008 The Great Escape/","excerpt":"POI2008 The Great Escape","text":"POI2008 The Great Escape 题目大意：给出一个$n \\times m$的地图，计算从(n,1)走到(y,x)的路径条数。答案对k取模，走过的点不能再走，转弯只能向右转。（有的格子可能存在障碍，不能走） ($ n,m \\le 100$) 题解：借鉴了Sengxian的题解 戳这儿 模拟数据，我们不难发现，路径都是绕着圈圈到达的。 由于走过的点不能再走，并且转弯只能向右转，因而，路径的圈一定是越转越小的。 为了方便，我们计算从(y,x)走到(n,1)的方案数，转弯只能向左转。这样圈一定是越转越大的。 定义dp[x1][y1][x2][y2][0~4]表示从(y,x)出发，所走的路径上界为x1，下界为x2，左界为y1，右界为y2，终点分别为(x1,y2)、(x2,y2)、(x2,y1)、(x1,y1)的可行路径数。 看右上角的点: dp[x1][y1][x2][y2][0] $ \\leftarrow $ dp[x1][y1][x2][y2-1][1] （从右下角的点向左转） dp[x1][y1][x2][y2][0] $ \\leftarrow $ dp[x1+1][y1][x2][y2][0] （从右上角的点直接走） 同理可以得到其余三个角的转移方程： dp[x1][y1][x2][y2][1] $ \\leftarrow $ dp[x1][y1][x2-1][y2][2] + dp[x1][y1][x2][y2-1][1] dp[x1][y1][x2][y2][2] $ \\leftarrow $ dp[x1][y1+1][x2][y2][3] + dp[x1][y1][x2-1][y2][2] dp[x1][y1][x2][y2][3] $ \\leftarrow $ dp[x1+1][y1][x2][y2][0] + dp[x1][y1+1][x2][y2][3] 设立初值比较麻烦，Sengxian的方法是将起点 (y,x)需要的状态设置为 1（哪怕这个状态不合格），这样比较方便。 这样一来，时间复杂度为$O(n^4)$ ，空间上可以用滚动数组来优化，复杂度为$O(n^3)$。 PS. 状态的定义比较奇妙，蛮神的一道dp题。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=105;int n,m,mod,x,y,ans;char str[N];int lin[N][N],row[N][N],dp[2][N][N][N][4];void Mod(int&amp;a,int b)&#123; a+=b; if(a&gt;=mod)a-=mod;&#125;int main()&#123; scanf(\"%d%d%d%d%d\",&amp;n,&amp;m,&amp;mod,&amp;y,&amp;x); for(int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",str+1); for(int j=1;j&lt;=m;j++)&#123; lin[i][j]=lin[i][j-1]+(str[j]=='+'); row[j][i]=row[j][i-1]+(str[j]=='+'); &#125; &#125; bool cur=0; dp[cur][y][x][y-1][1]=1; dp[cur][y][x-1][y][2]=1; dp[cur][y+1][x][y][3]=1; dp[cur^1][y][x][y][0]=1; for(int x1=x;x1&gt;=1;x1--,cur^=1)&#123; if(x1!=x)memset(dp[cur],0,sizeof(dp[cur])); for(int y1=y;y1&gt;=1;y1--)&#123; for(int x2=x;x2&lt;=n;x2++)&#123; for(int y2=y;y2&lt;=m;y2++)&#123; if(row[y2][x2]-row[y2][x1-1]==x2-x1+1)&#123; dp[cur][y1][x2][y2][0]=dp[cur][y1][x2][y2-1][1]; if(x1&lt;x2)Mod(dp[cur][y1][x2][y2][0],dp[cur^1][y1][x2][y2][0]); &#125; if(lin[x2][y2]-lin[x2][y1-1]==y2-y1+1)&#123; dp[cur][y1][x2][y2][1]=dp[cur][y1][x2-1][y2][2]; if(y1&lt;y2)Mod(dp[cur][y1][x2][y2][1],dp[cur][y1][x2][y2-1][1]); &#125; if(row[y1][x2]-row[y1][x1-1]==x2-x1+1)&#123; dp[cur][y1][x2][y2][2]=dp[cur][y1+1][x2][y2][3]; if(x1&lt;x2)Mod(dp[cur][y1][x2][y2][2],dp[cur][y1][x2-1][y2][2]); &#125; if(lin[x1][y2]-lin[x1][y1-1]==y2-y1+1)&#123; dp[cur][y1][x2][y2][3]=dp[cur^1][y1][x2][y2][0]; if(y1&lt;y2)Mod(dp[cur][y1][x2][y2][3],dp[cur][y1+1][x2][y2][3]); &#125; if(x2==n&amp;&amp;y1==1)Mod(ans,dp[cur][y1][x2][y2][2]); &#125; &#125; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://YummyJay.github.io/tags/dp/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"20161025","slug":"20161025","date":"2016-10-25T10:42:20.000Z","updated":"2016-10-25T11:29:59.681Z","comments":true,"path":"2016/10/25/20161025/","link":"","permalink":"https://YummyJay.github.io/2016/10/25/20161025/","excerpt":"心情","text":"心情 现在是2016年10月25日，距离noip复赛还有25天。 这是我的第一次noip，但也许也是最后一次。 我想，以后也很少有机会像现在这样义无反顾的去做某些事情了吧，所以一定要珍惜现在学OI的日子。 总觉得最近状态不是很好。 今天早上比了一场离线赛，比的很差。 很久没有比得那么差了，这让我一时间心很慌。 用这种状态去比复赛，估计连提高一等也没有，直接光荣退役。 其实有些时候，有些东西是没什么好犹豫的，认定了就去干，想太多了反而不好。 最起码以后回忆起来，我能笑着说，我已经尽力了。 其实，自打出生起，我就从来没有认为自己适合竞赛这一条路。 数学自是不用讲了。 还记得学物理竞赛的那段日子，总感觉日子浑浑噩噩，找不到存在的价值。 很疲惫，很不堪。 于是放弃，打算转战高考。 但就在这时，同学把我拉到了机房，教练拍拍我的肩膀说，学OI也挺好。 很好！ 于是在高一，在9月底，我开始了我的OI生涯。 遗憾的是错过了2015届的初赛报名，起步又比较晚，只有高二一次机会了。 但其实真的很开心，看到代码从指间流淌出来，成就感很高。 从此，走上不归路。 或许出不出成绩都并不重要，重要的是经历。 等长大了，回想起高中学OI的经历，总是泪中含笑的吧。 不后悔，不放弃，也就够了吧。 愿一切都更好！ 以上。","categories":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/categories/杂/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/tags/杂/"}],"keywords":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/categories/杂/"}]},{"title":"POI2008 Mafia","slug":"POI2008 Mafia","date":"2016-10-23T07:21:06.000Z","updated":"2016-10-23T14:09:12.745Z","comments":true,"path":"2016/10/23/POI2008 Mafia/","link":"","permalink":"https://YummyJay.github.io/2016/10/23/POI2008 Mafia/","excerpt":"POI2008 Mafia","text":"POI2008 Mafia 题目大意：有n个人，每一个人有一把手枪。一开始，所有的人都选定一个人瞄准(有可能瞄准自己)。然后他们按照某一个顺序开枪，且任意时刻只有一个人开枪。因此，对于不同的开枪顺序，最后死掉的人也不同。问最后死亡人数的最小和最大可能值。 ( $n\\le 10^6$ ) 题解：首先很容易看出，图是一个基环外向树，那么我们就可以借助一些基环外向树的性质来解题了。 对于最大的可能人数，我们比较好得到。只要让存活人数最少就可以了，那么就让那些一定不会死的人活下来，其他人都可以杀掉。 不会死的人有两种： 入度为0的人。由于没有人拿枪瞄准他们，显然不会死。 当一个基环外向树没有”树枝”，而只有中间那一个环时，我们没有办法将环上的人全部杀完，总要留下一个。留下的那个就可以不用死。(中间的环不能是自环，不然当然可以把环上的人杀完) 利用拓扑排序随便搞一下，这部分就可以解决了。 接下来看看最小的可能人数： 一个人会不会死关键看是否有一个没死的人拿枪指着他。 也就是说，如果有一个人没死，那么被他指的人一定会死。 首先，入度为零的人，一定不会死，但是被他指的人全都会死。 为了让活着的人尽量多，我们不妨让死了的人都不开枪。 那么对于一个必死的人，他所瞄准的人都少了一次被杀死的机会，可以把它们的入度减一。 如果入度减为了零，说明所有的威胁都被排除，此人已经死不了了。 由此，我们可以把基环外向树上的”树枝”全部清理掉。 对于留下的环，我们从环上任意一个人开始，让他死，那么环也就可以流动起来了。 其实最小值也可以用树形dp来写。 题目转化一下就可以变为： 我们把基环外向树的边都变为双向的。然后在树上取一些点(表示这些点活着)，且两个被取的点不能相邻，最大化取的点的数量。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=1000005;int n,aim[N],cnt[N],ans;bool used[N];void work(int p,int c)&#123; if(used[p])return; used[p]=true; ans+=c; if(!(--cnt[aim[p]])||c)work(aim[p],c^1);&#125;int solve_min()&#123; ans=0; memset(cnt,0,sizeof(cnt)); memset(used,0,sizeof(used)); for(int i=1;i&lt;=n;i++)cnt[aim[i]]++; for(int i=1;i&lt;=n;i++) if(!cnt[i])work(i,1); for(int i=1;i&lt;=n;i++)work(i,0); return n-ans;&#125;queue&lt;int&gt;que;void check_loop(int p)&#123; bool flag=false; for(int pre=p;flag|=used[p],aim[p]!=pre;cnt[aim[p]]--,p=aim[p]); if(!flag)ans++;&#125;int solve_max()&#123; ans=0; memset(cnt,0,sizeof(cnt)); memset(used,0,sizeof(used)); for(int i=1;i&lt;=n;i++)cnt[aim[i]]++; while(!que.empty())que.pop(); for(int i=1;i&lt;=n;i++) if(!cnt[i])que.push(i),ans++; while(!que.empty())&#123; int p=que.front();que.pop(); if(!(--cnt[aim[p]]))que.push(aim[p]); else used[aim[p]]=true; &#125; for(int i=1;i&lt;=n;i++) if(cnt[i]&amp;&amp;i!=aim[i])check_loop(i); return n-ans;&#125;int solve()&#123; printf(\"%d %d\\n\",solve_min(),solve_max()); return 0;&#125;int main()&#123; Rd(n); for(int i=1;i&lt;=n;i++)Rd(aim[i]); return solve();&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://YummyJay.github.io/tags/拓扑排序/"},{"name":"贪心","slug":"贪心","permalink":"https://YummyJay.github.io/tags/贪心/"},{"name":"基环外向树","slug":"基环外向树","permalink":"https://YummyJay.github.io/tags/基环外向树/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"noip2016初赛","slug":"noip2016初赛","date":"2016-10-22T11:31:28.000Z","updated":"2016-10-22T11:39:03.290Z","comments":true,"path":"2016/10/22/noip2016初赛/","link":"","permalink":"https://YummyJay.github.io/2016/10/22/noip2016初赛/","excerpt":"noip2016初赛","text":"noip2016初赛 总觉得初赛很折磨人，稍微一个不小心就可能会“光荣退役”。 作为一个高二才参加第一次初赛的蒟蒻，这一次初赛更显得有些令人担忧，就怕还没开始就已经结束。 还好，并没有遇到什么大的问题，完善程序第一个空写错扣了两分，其他的倒也都没什么了。 总算我的OI生涯没有因为初赛而终止，复赛加油！！！ 以上。","categories":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/categories/杂/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/tags/杂/"}],"keywords":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/categories/杂/"}]},{"title":"POI2008 Robinson","slug":"POI2008 Robinson","date":"2016-10-21T06:39:25.000Z","updated":"2016-10-21T07:06:02.915Z","comments":true,"path":"2016/10/21/POI2008 Robinson/","link":"","permalink":"https://YummyJay.github.io/2016/10/21/POI2008 Robinson/","excerpt":"POI2008 Robinson","text":"POI2008 Robinson 题目大意：给出一个地图，上面有水，还有一些点不能抵达。你要开着船从水上走出这个地图，而不使船碰到不能抵达的点。问最少要多少步。(可能无解) ( $ 3 \\le n \\le 2000$ ) 题解：求最少步数，用广搜是比较显然的。 我们定义船最长的一行和最长的一列的交点为船的中心。 那么重点就在于处理船可以将中心移动到那些点上。 首先我们枚举一个点$(x,y)$，找到该点向上走到达的第一个不可抵达的点，由此可以算出一个船在x这一行左右移动，一个不可行的区间。同理，向下走找到第一个不可抵达的点，也可得到一个不可行的区间。 同理，我们也可以用这种方法求，一个船在y这一列上下移动，若干个不可行的区间。 对于这些区间，我们可以直接用差分前缀和维护，从而$O(n^2)$预处理出每一个点是否可行。 之后再广搜。 还有一个值得注意的地方，那就是当中心移到边缘时，船还不算出去了，还要把整个船身都移出去才可以。 这可以通过船所在的边缘，直接预处理出代价。 另外，如果船的中心从图的一个角出去，代价需要另外预处理。 综上，总的时间复杂度为$O(n^2)$。 说起来比较容易，但敲起来比较痛。随便敲一下就200+了，又调试了半天，总算解决了。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=2002,inf=1&lt;&lt;30;void Min(int&amp;a,int b)&#123; if(b&lt;a)a=b;&#125;void Max(int&amp;a,int b)&#123; if(b&gt;a)a=b;&#125;char str[N][N];int n,xu,xd,yl,yr,xm,ym;int ul[N],ur[N],dl[N],dr[N];int up[N],dw[N],sum[N][N];bool cov[N][N];struct node&#123; int x,y,step;&#125;;queue&lt;node&gt;que;int rx[]=&#123;0,1,0,-1&#125;;int ry[]=&#123;1,0,-1,0&#125;;bool used[N][N];bool judge(int x,int y)&#123;//该点能否到达 if(x&lt;=0||x&gt;n||y&lt;=0||y&gt;n||cov[x][y]||used[x][y])return false; return true;&#125;int ans,step11,step1n,stepn1,stepnn;void check_ans(int x,int y,int step)&#123; //从边缘出去 if(x==1)Min(ans,step+xd-xm+1); if(x==n)Min(ans,step+xm-xu+1); if(y==1)Min(ans,step+yr-ym+1); if(y==n)Min(ans,step+ym-yl+1); //从角落出去 if(x==1&amp;&amp;y==1)Min(ans,step+step11); if(x==1&amp;&amp;y==n)Min(ans,step+step1n); if(x==n&amp;&amp;y==1)Min(ans,step+stepn1); if(x==n&amp;&amp;y==n)Min(ans,step+stepnn);&#125;int BFS()&#123;//广搜 ans=inf; while(!que.empty())que.pop(); used[xm][ym]=true; que.push((node)&#123;xm,ym,0&#125;); check_ans(xm,ym,0); while(!que.empty())&#123; node cur=que.front(); que.pop(); int px=cur.x,py=cur.y,pstep=cur.step; for(int i=0;i&lt;4;i++)&#123; int nx=px+rx[i],ny=py+ry[i],nstep=pstep+1; if(judge(nx,ny))&#123; used[nx][ny]=true; check_ans(nx,ny,nstep); que.push((node)&#123;nx,ny,nstep&#125;); &#125; &#125; &#125; if(ans!=inf)printf(\"%d\\n\",ans); else printf(\"NIE\\n\"); return 0;&#125;int main()&#123; scanf(\"%d\",&amp;n); xu=yl=inf,xd=yr=0; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",str[i]+1); for(int j=1;j&lt;=n;j++)&#123; if(str[i][j]=='r')&#123; Min(xu,i),Max(xd,i); Min(yl,j),Max(yr,j); &#125; &#125; &#125; for(int i=xu;i&lt;=xd;i++)&#123; int cnt=0; for(int j=yl;j&lt;=yr;j++)&#123; if(str[i][j]=='r')cnt++; &#125; if(cnt==yr-yl+1)xm=i; &#125; for(int j=yl;j&lt;=yr;j++)&#123; int cnt=0; for(int i=xu;i&lt;=xd;i++)&#123; if(str[i][j]=='r')cnt++; &#125; if(cnt==xd-xu+1)ym=j; &#125; memset(sum,0,sizeof(sum)); for(int i=xu;i&lt;=xm;i++)&#123; int d=xm-i; ul[d]=inf,ur[d]=0; for(int j=yl;j&lt;=yr;j++)&#123; if(str[i][j]=='r')&#123; Min(ul[d],j); Max(ur[d],j); &#125; &#125; ul[d]=ym-ul[d]; ur[d]=ur[d]-ym; &#125; for(int i=xm;i&lt;=xd;i++)&#123; int d=i-xm; dl[d]=inf,dr[d]=0; for(int j=yl;j&lt;=yr;j++)&#123; if(str[i][j]=='r')&#123; Min(dl[d],j); Max(dr[d],j); &#125; &#125; dl[d]=ym-dl[d]; dr[d]=dr[d]-ym; &#125; for(int j=1;j&lt;=n;j++)&#123; up[0]=dw[n+1]=inf; for(int i=1;i&lt;=n;i++)&#123; if(str[i][j]=='X')up[i]=0; else up[i]=up[i-1]+1; &#125; for(int i=n;i&gt;=1;i--)&#123; if(str[i][j]=='X')dw[i]=0; else dw[i]=dw[i+1]+1; &#125; for(int i=1;i&lt;=n;i++)&#123; int L=n,R=1; if(up[i]&lt;=xm-xu)&#123; Min(L,j-ur[up[i]]); Max(R,j+ul[up[i]]); &#125; if(dw[i]&lt;=xd-xm)&#123; Min(L,j-dr[dw[i]]); Max(R,j+dl[dw[i]]); &#125; Max(L,1),Min(R,n); if(L&lt;=R)sum[i][L]++,sum[i][R+1]--; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=1;j&lt;=n;j++)&#123; sum[i][j]+=sum[i][j-1]; if(sum[i][j])cov[i][j]=true; &#125; &#125; memset(sum,0,sizeof(sum)); for(int j=yl;j&lt;=ym;j++)&#123; int d=ym-j; ul[d]=inf,ur[d]=0; for(int i=xu;i&lt;=xd;i++)&#123; if(str[i][j]=='r')&#123; Min(ul[d],i); Max(ur[d],i); &#125; &#125; ul[d]=xm-ul[d]; ur[d]=ur[d]-xm; &#125; for(int j=ym;j&lt;=yr;j++)&#123; int d=j-ym; dl[d]=inf,dr[d]=0; for(int i=xu;i&lt;=xd;i++)&#123; if(str[i][j]=='r')&#123; Min(dl[d],i); Max(dr[d],i); &#125; &#125; dl[d]=xm-dl[d]; dr[d]=dr[d]-xm; &#125; for(int i=1;i&lt;=n;i++)&#123; up[0]=dw[n+1]=inf; for(int j=1;j&lt;=n;j++)&#123; if(str[i][j]=='X')up[j]=0; else up[j]=up[j-1]+1; &#125; for(int j=n;j&gt;=1;j--)&#123; if(str[i][j]=='X')dw[j]=0; else dw[j]=dw[j+1]+1; &#125; for(int j=1;j&lt;=n;j++)&#123; int L=n,R=1; if(up[j]&lt;=ym-yl)&#123; Min(L,i-ur[up[j]]); Max(R,i+ul[up[j]]); &#125; if(dw[j]&lt;=yr-ym)&#123; Min(L,i-dr[dw[j]]); Max(R,i+dl[dw[j]]); &#125; Max(L,1),Min(R,n); if(L&lt;=R)sum[j][L]++,sum[j][R+1]--; &#125; &#125; for(int j=1;j&lt;=n;j++)&#123; for(int i=1;i&lt;=n;i++)&#123; sum[j][i]+=sum[j][i-1]; if(sum[j][i])cov[i][j]=true; &#125; &#125; //预处理船从四个角出去所花的最少代价 step11=step1n=stepn1=stepnn=inf; for(int i=1;i&lt;=ym-yl;i++)&#123; Min(step1n,i+ur[i]+1); Min(stepnn,i+ul[i]+1); &#125; for(int i=1;i&lt;=yr-ym;i++)&#123; Min(stepn1,i+dl[i]+1); Min(step11,i+dr[i]+1); &#125; return BFS();&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://YummyJay.github.io/tags/BFS/"},{"name":"差分前缀和","slug":"差分前缀和","permalink":"https://YummyJay.github.io/tags/差分前缀和/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2008 Trains","slug":"POI2008 Trains","date":"2016-10-20T02:02:58.000Z","updated":"2016-10-20T02:31:29.933Z","comments":true,"path":"2016/10/20/POI2008 Trains/","link":"","permalink":"https://YummyJay.github.io/2016/10/20/POI2008 Trains/","excerpt":"POI20008 Trains","text":"POI20008 Trains 题目大意：有n列火车，每列火车有L节车厢。每节车厢有一种颜色(用小写字母来表示)。有m次交换车厢的操作。求：对于每一列火车，在交换车厢的某一个时刻，与其颜色完全相同的火车最多有多少。 ( $ 2 \\le n \\le 1000 $ , $ 1 \\le L \\le 100 $ , $ 0 \\le m \\le 100000 $ ) 题解：完全是码农题。。。 字符串hash是比较显然的。之后对于每一个hash值，我们建一棵Treap维护hash值为该值的字符串的下标。 用map来存每一棵Treap的根。 按照题目要求进行操作即可。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;map&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=1001,P=233;int stk[N],top,ans[N];struct Treap&#123; struct node&#123; int ch[2],key,val,sz,flag; &#125;tree[N]; void pushup(int&amp;p)&#123; tree[p].sz=tree[tree[p].ch[0]].sz+tree[tree[p].ch[1]].sz+1; &#125; void maintain(int&amp;p,int flag)&#123; int val=tree[p].val; ans[val]=max(ans[val],flag); tree[p].flag=max(tree[p].flag,flag); &#125; void pushdown(int&amp;p)&#123; if(!tree[p].flag)return; int ls=tree[p].ch[0],rs=tree[p].ch[1]; if(ls)maintain(ls,tree[p].flag); if(rs)maintain(rs,tree[p].flag); tree[p].flag=0; &#125; void rotate(int&amp;p,int d)&#123; int k=tree[p].ch[d^1]; pushdown(p),pushdown(k); tree[p].ch[d^1]=tree[k].ch[d]; tree[k].ch[d]=p; pushup(p),pushup(k);p=k; &#125; void insert(int&amp;p,int x)&#123; if(!p)&#123; p=stk[top--]; tree[p].key=rand(),tree[p].val=x,tree[p].sz=1; tree[p].ch[0]=tree[p].ch[1]=tree[p].flag=0; &#125;else&#123; pushdown(p); tree[p].sz++; bool d=x&gt;tree[p].val; insert(tree[p].ch[d],x); if(tree[p].key&lt;tree[tree[p].ch[d]].key)rotate(p,d^1); &#125; pushup(p); &#125; void erase(int&amp;p,int x)&#123; pushdown(p); tree[p].sz--; if(tree[p].val==x)&#123; if(!tree[p].ch[0])stk[++top]=p,p=tree[p].ch[1]; else if(!tree[p].ch[1])stk[++top]=p,p=tree[p].ch[0]; else&#123; bool d=tree[tree[p].ch[0]].key&gt;tree[tree[p].ch[1]].key; rotate(p,d);erase(tree[p].ch[d],x); &#125; &#125;else&#123; bool d=x&gt;tree[p].val; erase(tree[p].ch[d],x); &#125; if(p)pushup(p); &#125; int size(int p)&#123; return tree[p].sz; &#125;&#125;T;typedef unsigned long long ull;map&lt;ull,int&gt;rt;ull hash_val[N],p[101];char str[N][101];int n,l,m;void INSERT(int x)&#123; T.insert(rt[hash_val[x]],x); int t=rt[hash_val[x]]; T.maintain(t,T.size(t));&#125;void DELETE(int x)&#123; T.erase(rt[hash_val[x]],x);&#125;int main()&#123; Rd(n),Rd(l),Rd(m); for(int i=n;i&gt;=1;i--)stk[++top]=i; p[0]=1; for(int i=1;i&lt;=l;i++)p[i]=p[i-1]*P; for(int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",str[i]); for(int j=0;j&lt;l;j++) hash_val[i]=hash_val[i]*P+str[i][j]; INSERT(i); &#125; for(int i=1;i&lt;=m;i++)&#123; int a,b,c,d; Rd(a),Rd(b),Rd(c),Rd(d); DELETE(a); if(a!=c)DELETE(c); hash_val[a]=hash_val[a]-p[l-b]*str[a][b-1]+p[l-b]*str[c][d-1]; hash_val[c]=hash_val[c]-p[l-d]*str[c][d-1]+p[l-d]*str[a][b-1]; swap(str[a][b-1],str[c][d-1]); INSERT(a); if(a!=c)INSERT(c); &#125; for(int i=1;i&lt;=n;i++)DELETE(i); for(int i=1;i&lt;=n;i++)&#123; printf(\"%d\\n\",ans[i]); &#125; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"Treap","slug":"Treap","permalink":"https://YummyJay.github.io/tags/Treap/"},{"name":"hash","slug":"hash","permalink":"https://YummyJay.github.io/tags/hash/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2008 BBB","slug":"POI2008 BBB","date":"2016-10-19T11:09:53.000Z","updated":"2016-10-19T11:45:33.888Z","comments":true,"path":"2016/10/19/POI2008 BBB/","link":"","permalink":"https://YummyJay.github.io/2016/10/19/POI2008 BBB/","excerpt":"POI2008 BBB","text":"POI2008 BBB 题目大意：有一个长度为n的记账单。”+”表示存一元钱，”-“表示取一元钱。现在发现记账单有问题。一开始本来已经有了p元钱，并且知道最后账户上还有q元钱。你需要把账户修改正确，使得： 账户永远不会出现负数。 最后账户上还有q元钱。 你有两种操作： 对某一位取反，耗时x。 把最后一位移到第一位，耗时y。 问最少耗时为多少。 ( $n \\le 10^6 $ , $0 \\le p,q \\le 10^6 $ , $ 1 \\le x,y \\le 1000$ ) 题解：首先有一个想法就是把操作1与操作2分开。先枚举进行操作2的次数，再在此基础上进行操作1以达到要求。 问题就变成了，对于一个固定的字符串，我们只用操作1使得其满足条件。 要满足账户永远不会出现负数，那么只需要满足前缀和最小的那个点的前缀和不小于0即可。 因此我们把前缀和最小的那个点前面的”-“依次变为”+”，则一定可满足这个条件。 接下来还有一个条件，那就是最后账户上还有q元钱。我们只需要加上额外的操作1的次数使其满足即可。(要么把前面的”-“变成”+”，要么把后面的”+”变成”-“) 前缀和最小的那个点，可以用单调队列直接全部预处理出来，复杂度为$O(n)$。 (当然可以用线段树无脑算，复杂度为$O(nlogn)$) Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=1000001,inf=1&lt;&lt;30;int n,p,q,x,y,sum[N&lt;&lt;1];char str[N];char opt(int i)&#123; if(i&gt;n)i-=n; return str[i];&#125;int id[N],que[N&lt;&lt;1];int main()&#123; Rd(n),Rd(p),Rd(q),Rd(x),Rd(y); scanf(\"%s\",str+1); for(int i=1;i&lt;=n*2;i++)&#123; if(opt(i)=='+')sum[i]=sum[i-1]+1; else sum[i]=sum[i-1]-1; &#125; int L=1,R=0; for(int r=2*n,l=2*n+1;r&gt;n&amp;&amp;l&gt;0;r--)&#123; while(L&lt;=R&amp;&amp;que[L]&gt;r)L++; while(r-l+1&lt;n)&#123; l--; while(L&lt;=R&amp;&amp;sum[que[R]]&gt;=sum[l])R--; que[++R]=l; &#125; id[r-n]=que[L]; &#125; int ans=inf; for(int i=1;i&lt;=n;i++)&#123; int l=i+1,r=i+n,tmp=q-p-sum[n]; int res=(n-i)*y,dalt=sum[l-1]-sum[id[i]]-p; if(dalt&gt;0)res+=(dalt+1)/2*x,tmp-=(dalt+1)/2*2; res+=abs(tmp/2)*x; ans=min(ans,res); &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"单调队列","slug":"单调队列","permalink":"https://YummyJay.github.io/tags/单调队列/"},{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2008 Blockade","slug":"POI2008 Blockade","date":"2016-10-18T13:50:43.000Z","updated":"2016-10-18T23:19:11.083Z","comments":true,"path":"2016/10/18/POI2008 Blockade/","link":"","permalink":"https://YummyJay.github.io/2016/10/18/POI2008 Blockade/","excerpt":"POI2008 Blockade","text":"POI2008 Blockade 题目大意：城市中有n个小镇，m条双向边。每一条双向边连接两个不同的小镇，保证没有重复的边，并且保证所有的小镇连通。输出n个数，代表如果把第i个点删掉，将有多少个点对不能互通。 ($ n \\le 10^5 $ , $ m \\le 5 \\times 10^5 $ ) 题解：首先来介绍一下块割树（并不知道明确的定义，仅凭理解扯皮）： 我们知道一个无向图的割点可能属于多个点双连通分量，因而一般我们进行点双连通分量分解时在栈中存边，以每一条边的归属来把图分解。 但块割树并不在栈中存边，它在栈中存点。那如何解决一个割点属于多个点双连通分量的情况呢? 块割树在缩点时，并不把一个点双连通分量看做一个节点。每一个点双连通分量除去割点的部分缩为一个点，割点独自成点。这样就能够保证把图缩为一棵树。并且不会存在一个点在缩点后属于多个节点的情况。 接下来看看这道题： 首先我们点双联通分量分解，构造出一棵块割树。 若去掉的点不是割点，那么答案即为$(n-1) \\times 2$. 否则，要加上由于割点去掉而使得一些点对不再相连的情况。这个树形dp搞一下就可以了。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;typedef vector&lt;int&gt; vec;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=100001,M=500001;int n,m,tot_edge,head[N&lt;&lt;1];struct Edge&#123; int to,nxt;&#125;edge[M&lt;&lt;1];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;int tot,low[N],dfn[N],stk[N],top;vector&lt;vec&gt;blo;vec cut;void pack(int p,int to)&#123; vec tmp=vec(1,p); for(;;)&#123; int cur=stk[top];top--; tmp.push_back(cur); if(cur==to)break; &#125; blo.push_back(tmp);&#125;void Tarjan(int p)&#123; low[p]=dfn[p]=++tot; stk[++top]=p; bool ok=false; int child=0; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(!dfn[to])&#123; Tarjan(to);child++; low[p]=min(low[p],low[to]); if(low[to]&gt;=dfn[p])&#123; ok=true; pack(p,to); &#125; &#125;else low[p]=min(low[p],dfn[to]); &#125; if(dfn[p]==1)&#123; ok=child&gt;1; if(!child)blo.push_back(vec(1,p)); &#125; if(ok)cut.push_back(p);&#125;int idx[N],cnt[N&lt;&lt;1],num[N&lt;&lt;1],fa[N&lt;&lt;1];void dfs(int p,int f)&#123; cnt[p]=num[p],fa[p]=f; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; dfs(to,p); cnt[p]+=cnt[to]; &#125;&#125;ll ans[N];int solve()&#123; for(int i=1;i&lt;=n;i++)printf(\"%lld\\n\",ans[i]); return 0;&#125;int main()&#123; Rd(n),Rd(m); memset(head,-1,sizeof(head)); for(int i=1,a,b;i&lt;=m;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); &#125; Tarjan(1); for(int i=0;i&lt;cut.size();i++)&#123; int p=cut[i]; idx[p]=blo.size()+i+1; &#125; memset(head,-1,sizeof(head)),tot_edge=0; for(int i=0;i&lt;blo.size();i++)&#123; const vec&amp; cur=blo[i]; vec tmp; for(int j=0;j&lt;cur.size();j++)&#123; int p=cur[j]; if(idx[p])&#123; add_edge(i+1,idx[p]); add_edge(idx[p],i+1); &#125;else num[i+1]++; &#125; &#125; for(int i=0;i&lt;cut.size();i++)num[idx[cut[i]]]=1; dfs(1,0); for(int i=1;i&lt;=n;i++)ans[i]=n-1&lt;&lt;1; for(int i=0;i&lt;cut.size();i++)&#123; int p=cut[i],id=idx[p]; for(int j=head[id];~j;j=edge[j].nxt)&#123; int to=edge[j].to; if(to==fa[id])continue; ans[p]+=1LL*cnt[to]*(n-1-cnt[to]); &#125; int c=n-cnt[id]; ans[p]+=1LL*c*(n-1-c); &#125; return solve();&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"块割树","slug":"块割树","permalink":"https://YummyJay.github.io/tags/块割树/"},{"name":"图的连通性","slug":"图的连通性","permalink":"https://YummyJay.github.io/tags/图的连通性/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2008 Postering","slug":"POI2008 Postering","date":"2016-10-18T11:07:35.000Z","updated":"2016-10-18T13:34:16.356Z","comments":true,"path":"2016/10/18/POI2008 Postering/","link":"","permalink":"https://YummyJay.github.io/2016/10/18/POI2008 Postering/","excerpt":"POI2008 Postering","text":"POI2008 Postering 题目大意：有n个矩形排成一排，现在希望用尽量少的矩型海报覆盖住它们。问最少需要几张海报。 题解：首先我们可以知道，n张海报是一定可以满足条件的。大不了每一个矩形我都用一张海报。 但实际上，这肯定是不用这么多的。 当我们遇到这种情况时，我们不需要三张海报，而只需要两张。 总结一下我们发现，如果两个矩形高度相同，并且它们之间的矩形高度都比它们高，那么我们可以少花一个代价。 首先枚举两个相同高度的矩形，再用线段树求区间最小值，看是否满足条件。 这样题目就能够AC了，复杂度为$O(nlogn)$。 但实际上可以不这么写。我们维护一个单调栈，即可在$O(n)$的时间内解决该题。 Code: 线段树 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=250001;int n,num[N],tmp[N];struct Segment_Tree&#123; struct node&#123; int L,R,mi; &#125;tree[N&lt;&lt;2]; void pushup(int p)&#123; tree[p].mi=min(tree[p&lt;&lt;1].mi,tree[p&lt;&lt;1|1].mi); &#125; void build(int L,int R,int p)&#123; tree[p].L=L,tree[p].R=R; if(L==R)&#123; tree[p].mi=num[L]; return; &#125; int mid=L+R&gt;&gt;1; build(L,mid,p&lt;&lt;1); build(mid+1,R,p&lt;&lt;1|1); pushup(p); &#125; int query(int L,int R,int p)&#123; if(tree[p].L==L&amp;&amp;tree[p].R==R)&#123; return tree[p].mi; &#125; int mid=tree[p].L+tree[p].R&gt;&gt;1; if(R&lt;=mid)return query(L,R,p&lt;&lt;1); else if(L&gt;mid)return query(L,R,p&lt;&lt;1|1); else return min(query(L,mid,p&lt;&lt;1),query(mid+1,R,p&lt;&lt;1|1)); &#125;&#125;T;#include&lt;vector&gt;vector&lt;int&gt;h[N];int main()&#123; Rd(n); for(int i=1,a;i&lt;=n;i++)&#123; Rd(a),Rd(num[i]); tmp[i]=num[i]; &#125; sort(tmp+1,tmp+1+n); int len=unique(tmp+1,tmp+1+n)-tmp-1; for(int i=1;i&lt;=n;i++) num[i]=lower_bound(tmp+1,tmp+1+len,num[i])-tmp; T.build(1,n,1); for(int i=1;i&lt;=n;i++) h[num[i]].push_back(i); int ans=n; for(int i=1;i&lt;=len;i++)&#123; for(int j=1;j&lt;h[i].size();j++)&#123; int pre=h[i][j-1],cur=h[i][j]; if(T.query(pre,cur,1)&lt;i)continue; ans--; &#125; &#125; printf(\"%d\\n\",ans); return 0;&#125; 单调栈 12345678910111213141516171819202122232425262728#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=250001;int n,stk[N],top;int main()&#123; Rd(n); stk[top++]=0; int ans=n; for(int i=1,a,b;i&lt;=n;i++)&#123; Rd(a),Rd(b); while(stk[top-1]&gt;=b)&#123; if(stk[top-1]==b)ans--; top--; &#125; stk[top++]=b; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://YummyJay.github.io/tags/线段树/"},{"name":"单调栈","slug":"单调栈","permalink":"https://YummyJay.github.io/tags/单调栈/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2008 Building blocks","slug":"POI2008 Building blocks","date":"2016-10-18T10:39:19.000Z","updated":"2016-10-18T11:05:13.970Z","comments":true,"path":"2016/10/18/POI2008 Building blocks/","link":"","permalink":"https://YummyJay.github.io/2016/10/18/POI2008 Building blocks/","excerpt":"POI2008 Building blocks","text":"POI2008 Building blocks 题目大意：有n块砖，我们现在希望有连续的k块砖的高度一样。你可以选择以下两种动作： 把某一块砖高度减一。 把某一块砖高度加一。 求完成任务最少要操作几次。 （ $n \\le 10^5$ , $h \\le 10^6$ ） 题解：首先肯定是枚举所有长度为k的区间。 接下来问题就变成了，已知一个区间，问把区间中所有数字权值都变相同，需要的最小代价。 有一个很明显的贪心：把所有的数字都变成，在这些数中排名为$(k+1)/2$的那个数。 于是问题就分成了两步： 找到排名为$(k+1)/2$的那个数$x$。 统计比$x$大的数的权值和$sum1$和个数$cnt1$，以及小于等于$x$的权值和$sum2$和个数$cnt2$。 那么答案即为：$sum1-cnt1 \\times x + cnt2 \\times x -sum2$. 我们可以利用一个线段树在$O(logh)$的时间内找到$x$，并用一个$BIT$来求权值和。 由于内存只有32MB，直接权值线段树会被卡。因而我们离散一下，复杂度变为$O(nlogn)$. Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=100005;int n,k,num[N],pos,tmp[N],len;struct Segment_Tree&#123; struct node&#123; int L,R,cnt; &#125;tree[N&lt;&lt;2]; void build(int L,int R,int p)&#123; tree[p].L=L,tree[p].R=R,tree[p].cnt=0; if(L==R)return; int mid=L+R&gt;&gt;1; build(L,mid,p&lt;&lt;1); build(mid+1,R,p&lt;&lt;1|1); &#125; void up(int p)&#123; tree[p].cnt=tree[p&lt;&lt;1].cnt+tree[p&lt;&lt;1|1].cnt; &#125; void update(int x,int v,int p)&#123; if(tree[p].L==tree[p].R)&#123; tree[p].cnt+=v; return; &#125; int mid=tree[p].L+tree[p].R&gt;&gt;1; if(x&lt;=mid)update(x,v,p&lt;&lt;1); else update(x,v,p&lt;&lt;1|1); up(p); &#125; int sum(int L,int R,int p)&#123; if(L&gt;R)return 0; if(tree[p].L==L&amp;&amp;tree[p].R==R)&#123; return tree[p].cnt; &#125; int mid=tree[p].L+tree[p].R&gt;&gt;1; if(R&lt;=mid)return sum(L,R,p&lt;&lt;1); else if(L&gt;mid)return sum(L,R,p&lt;&lt;1|1); else return sum(L,mid,p&lt;&lt;1)+sum(mid+1,R,p&lt;&lt;1|1); &#125; int query(int k,int p)&#123; if(tree[p].L==tree[p].R)return tree[p].L; int cntL=tree[p&lt;&lt;1].cnt; if(cntL&gt;=k)return query(k,p&lt;&lt;1); else return query(k-cntL,p&lt;&lt;1|1); &#125;&#125;ST;struct BIT&#123; ll bit[N]; #define lowbit(x) (x&amp;(-x)) void init()&#123; memset(bit,0,sizeof(bit)); &#125; void add(int p,int v)&#123; for(;p&lt;=len;p+=lowbit(p))bit[p]+=v; &#125; ll sum(int p)&#123; ll res=0; for(;p;p-=lowbit(p))res+=bit[p]; return res; &#125; ll query(int L,int R)&#123; return sum(R)-sum(L-1); &#125;&#125;BT;ll ans;const ll inf=1LL&lt;&lt;60;int limL,limR,midd;void solve(int l,int r)&#123; int p=ST.query(pos,1); int cntL=ST.sum(1,p,1),cntR=ST.sum(p+1,len,1); ll res=1LL*tmp[p]*cntL-BT.query(1,p); res+=BT.query(p+1,len)-1LL*tmp[p]*cntR; if(res&lt;ans)&#123; ans=res; limL=l,limR=r,midd=p; &#125;&#125;int main()&#123; Rd(n),Rd(k); pos=k+1&gt;&gt;1; for(int i=1;i&lt;=n;i++)Rd(num[i]),tmp[i]=++num[i]; sort(tmp+1,tmp+1+n); len=unique(tmp+1,tmp+1+n)-tmp-1; for(int i=1;i&lt;=n;i++)num[i]=lower_bound(tmp+1,tmp+1+len,num[i])-tmp; ST.build(1,len,1); BT.init(); for(int i=1;i&lt;=k;i++)&#123; ST.update(num[i],1,1); BT.add(num[i],tmp[num[i]]); &#125; ans=inf; solve(1,k); for(int i=k+1;i&lt;=n;i++)&#123; ST.update(num[i-k],-1,1); BT.add(num[i-k],-tmp[num[i-k]]); ST.update(num[i],1,1); BT.add(num[i],tmp[num[i]]); solve(i-k+1,i); &#125; cout&lt;&lt;ans&lt;&lt;endl; for(int i=1;i&lt;=n;i++)&#123; if(i&lt;=limR&amp;&amp;i&gt;=limL)printf(\"%d\\n\",tmp[midd]-1); else printf(\"%d\\n\",tmp[num[i]]-1); &#125; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://YummyJay.github.io/tags/线段树/"},{"name":"BIT","slug":"BIT","permalink":"https://YummyJay.github.io/tags/BIT/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2008 Toll","slug":"POI2008 Toll","date":"2016-10-18T10:10:18.000Z","updated":"2016-10-18T10:33:28.528Z","comments":true,"path":"2016/10/18/POI2008 Toll/","link":"","permalink":"https://YummyJay.github.io/2016/10/18/POI2008 Toll/","excerpt":"POI2008 Toll","text":"POI2008 Toll 题目大意：城市中有n个镇子，m条双向边。每一条边连接两个不同的小镇，并且保证没有重复的路。你要把其中一些路变成单向边，使得每一个小镇有且只有一个入度。 ( $n \\le 10^5$ , $m \\le 2 \\times 10^5$ ) 题解：倘若题目改成每一个小镇只有一个出度，实际上是对题目没有什么影响的。（可以理解成把留下的单向边方向都换一下，这样就满足每一个小镇只有一个出度了。） 但这样我们就可以发现，每一个连通块，最后构造出来的图一定是一棵基环外向树。 于是，只要每一个连通块都存在一个环，就一定可以构造出解。 我们可以用并查集来找环，并留下需要的无向边。 之后，利用拓扑排序给留下的边定向。遇到环时，断开环上任意一点，绕一圈即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=100001;int n,m;struct Edge&#123; int nxt[N&lt;&lt;2],to[N&lt;&lt;2],tot_edge,head[N]; Edge()&#123; memset(head,-1,sizeof(head)); &#125; void add_edge(int a,int b)&#123; to[tot_edge]=b; nxt[tot_edge]=head[a]; head[a]=tot_edge++; &#125;&#125;pre_edge,edge;#define traverse(edge,i,x) for(int i=edge.head[x];~i;i=edge.nxt[i])int tot_id;bool vis[N];int cnt[N],ans[N];queue&lt;int&gt;Q;vector&lt;int&gt;node[N];void dfs(int p)&#123; vis[p]=true;node[tot_id].push_back(p); traverse(pre_edge,i,p)&#123; int to=pre_edge.to[i]; if(!vis[to])dfs(to); &#125;&#125;int NO()&#123; puts(\"NIE\"); return 0;&#125;int YES()&#123; puts(\"TAK\"); for(int i=1;i&lt;=n;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;void solve(int p,int f)&#123; traverse(edge,i,p)&#123; int to=edge.to[i]; if(to==f)continue; if(!ans[to])&#123; ans[to]=p; return solve(to,p); &#125; &#125;&#125;struct Union&#123; int par[N]; void init()&#123; for(int i=1;i&lt;=n;i++)par[i]=i; &#125; int getpar(int p)&#123; if(par[p]!=p)par[p]=getpar(par[p]); return par[p]; &#125; void unite(int a,int b)&#123; a=getpar(a),b=getpar(b); par[a]=b; &#125; bool is_same(int a,int b)&#123; a=getpar(a),b=getpar(b); return a==b; &#125;&#125;U;int main()&#123; Rd(n),Rd(m); for(int i=1,a,b;i&lt;=m;i++)&#123; Rd(a),Rd(b); pre_edge.add_edge(a,b); pre_edge.add_edge(b,a); &#125; for(int i=1;i&lt;=n;i++)&#123; if(!vis[i])dfs(i),tot_id++; &#125; U.init(); memset(vis,0,sizeof(vis)); for(int i=0;i&lt;tot_id;i++)&#123; bool flag=false; for(int j=0;j&lt;node[i].size();j++)&#123; int p=node[i][j]; if(vis[p])continue; vis[p]=true; traverse(pre_edge,k,p)&#123; int to=pre_edge.to[k]; if(vis[to])continue; if(U.is_same(p,to))&#123; if(!flag)&#123; flag=true; edge.add_edge(p,to); edge.add_edge(to,p); cnt[p]++,cnt[to]++; &#125; &#125;else&#123; U.unite(p,to); edge.add_edge(p,to); edge.add_edge(to,p); cnt[p]++,cnt[to]++; &#125; &#125; &#125; if(!flag)return NO(); &#125; for(int i=1;i&lt;=n;i++)&#123; if(cnt[i]==1)Q.push(i); &#125; while(!Q.empty())&#123; int p=Q.front();Q.pop(); traverse(edge,i,p)&#123; int to=edge.to[i]; if(!ans[p]&amp;&amp;!ans[to])&#123; ans[p]=to; if((--cnt[to])==1)Q.push(to); &#125; &#125; &#125; for(int i=1;i&lt;=n;i++)&#123; if(!ans[i])solve(i,0); &#125; return YES();&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://YummyJay.github.io/tags/并查集/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"https://YummyJay.github.io/tags/拓扑排序/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013","slug":"POI2013","date":"2016-10-09T14:04:22.000Z","updated":"2016-10-09T14:18:55.840Z","comments":true,"path":"2016/10/09/POI2013/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013/","excerpt":"POI2013","text":"POI2013 写了这么久，终于把POI2013写的差不多了。 还留下两道计算几何题，也刷不动了，就此弃坑了吧。 截图留念： $PS.$ 话说超过100分是什么鬼啊！！！","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/tags/杂/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Walk","slug":"POI2013 Walk","date":"2016-10-09T13:09:00.000Z","updated":"2016-10-09T13:37:32.043Z","comments":true,"path":"2016/10/09/POI2013 Walk/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Walk/","excerpt":"POI2013 Walk","text":"POI2013 Walk 题目大意：有$2^n-k$个点，每个点有一个独一无二的、长度为n的01串，但是有k个01串没有出现过。每两个点之间有连边当且仅当两个01串之间有且仅有一个位置是不同的。现在询问x和y两个字符串能不能互相到达。 $PS.$ 感谢commonc大神的题解，以下内容借鉴了他的题解。 commonc的题解 题解：首先，这样的点所连的图与超立方体类似。 而对于超立方体有如下定理： 如果把所有顶点划分成为两个集合，这两个集合之间的边数至少是这两个点集中较小的那个的点的个数。 利用上述定理，我们可以利用反证法证明如下结论： 删去k个点后，一定至多存在一个连通块它的大小大于nk。 证明： 假设有两个独立的连通块S,T，它们的大小都大于nk。则有 $T \\subseteq V - S $ ,即 $\\mid V - S \\mid \\geq \\mid T \\mid \\geq nk+1 $ 由上述定理可知:$S$ 与$V-S$ 之间的边至少有nk+1条。 接着因为一共删掉了k个点，而每一个点向外连k条边，所以最多只能删掉nk+1条中的nk条边，也就是说$S$和$V-S$ 之间一定还有边相连。 这与S是一个独立集的假设矛盾，所以结论得证。 有了这个定理，我们可以直接BFS，当步数大于nk后，说明该点在最大的连通块内。 由此就可以快速判断两点是否在一个连通块内了。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;const int N=5000001,M=9999991;#define hash jksdafdjkint n,k,tot_id,head[M+5];char str[100];struct Hash&#123; ll id;int nxt;&#125;hash[N];void add_id(ll p)&#123; int pos=p%M; hash[++tot_id]=(Hash)&#123;p,head[pos]&#125;; head[pos]=tot_id;&#125;bool is_vis(ll p)&#123; int pos=p%M; for(int i=head[pos];i;i=hash[i].nxt) if(hash[i].id==p)return true; return false;&#125;ll string_ll()&#123; scanf(\"%s\",str); ll res=0; for(int i=0;i&lt;n;i++) res=res*2+(str[i]&amp;15); return res;&#125;ll s,t,que[N+5];int solve(ll cur)&#123; ll res=s+t-cur; int L=0,R=0; que[R++]=cur; add_id(cur); while(L&lt;R)&#123; ll p=que[L++]; for(int i=0;i&lt;n;i++)&#123; ll nxt=p^(1LL&lt;&lt;i); if(nxt==res)return 1; if(!is_vis(nxt))&#123; add_id(nxt); que[R++]=nxt; if(R&gt;=n*k)return 2; &#125; &#125; &#125; return 0;&#125;ll val[1000005];void YES()&#123; puts(\"TAK\"); exit(0);&#125;void NO()&#123; puts(\"NIE\"); exit(0);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;k); s=string_ll(),t=string_ll(); for(int i=1;i&lt;=k;i++)&#123; val[i]=string_ll(); add_id(val[i]); &#125; int ans1=solve(s); if(ans1==1)YES(); else if(ans1!=2)NO(); memset(head,0,sizeof(head));tot_id=0; for(int i=1;i&lt;=k;i++)add_id(val[i]); int ans2=solve(t); if(ans2==1||ans2==2)puts(\"TAK\"); else puts(\"NIE\"); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Laser","slug":"POI2013 Laser","date":"2016-10-09T12:54:32.000Z","updated":"2016-10-09T13:04:13.313Z","comments":true,"path":"2016/10/09/POI2013 Laser/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Laser/","excerpt":"POI2013 Laser","text":"POI2013 Laser 题目大意：给出n条线段。在(0,0)处引出k条射线，每一条线段最多被一条射线穿过，问最多一共可以穿过几条线段。 $PS.$ 算是蛮简单的一道题。 题解：把一个点反映成此点的斜率，那么穿过某线段的射线可反映为一个区间。 于是定义dp[i][j]表示引出i条射线后，在斜率为j处，发现了一条射线的最大价值。 用滚动数组滚掉一维，题目即可得解。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125; const int N=500001,inf=(int)1e9;int k,n,tot;int gcd(int a,int b)&#123; if(b==0)return a; return gcd(b,a%b);&#125;struct Fr&#123; int son,mom; bool operator &lt; (const Fr &amp;tmp)const&#123; return 1LL*son*tmp.mom&lt;1LL*mom*tmp.son; &#125; bool operator ==(const Fr &amp;tmp)const&#123; if(son==tmp.son&amp;&amp;mom==tmp.mom)return true; return false; &#125;&#125;tmp[N&lt;&lt;1];struct node&#123; Fr L,R;&#125;num[N];struct Segment&#123; int L,R;&#125;A[N];int dp[2][N&lt;&lt;1],mi[N&lt;&lt;1],sum[N&lt;&lt;1];struct Segment_Tree&#123; struct node&#123; int L,R,mi,flag; &#125;tree[N&lt;&lt;3]; void up(int p)&#123; tree[p].mi=min(tree[p&lt;&lt;1].mi,tree[p&lt;&lt;1|1].mi); &#125; void down(int p)&#123; if(tree[p].flag!=inf)&#123; tree[p&lt;&lt;1].mi=min(tree[p&lt;&lt;1].mi,tree[p].flag); tree[p&lt;&lt;1|1].mi=min(tree[p&lt;&lt;1|1].mi,tree[p].flag); tree[p&lt;&lt;1].flag=min(tree[p&lt;&lt;1].flag,tree[p].flag); tree[p&lt;&lt;1|1].flag=min(tree[p&lt;&lt;1|1].flag,tree[p].flag); tree[p].flag=inf; &#125; &#125; void build(int L,int R,int p)&#123; tree[p].L=L,tree[p].R=R,tree[p].flag=inf; if(L==R)&#123; tree[p].mi=L; return; &#125; int mid=L+R&gt;&gt;1; build(L,mid,p&lt;&lt;1); build(mid+1,R,p&lt;&lt;1|1); up(p); &#125; void update(int L,int R,int x,int p)&#123; if(tree[p].L==L&amp;&amp;tree[p].R==R)&#123; tree[p].mi=min(tree[p].mi,x); tree[p].flag=min(tree[p].flag,x); return; &#125; down(p); int mid=tree[p].L+tree[p].R&gt;&gt;1; if(R&lt;=mid)update(L,R,x,p&lt;&lt;1); else if(L&gt;mid)update(L,R,x,p&lt;&lt;1|1); else update(L,mid,x,p&lt;&lt;1),update(mid+1,R,x,p&lt;&lt;1|1); up(p); &#125; int query(int x,int p)&#123; if(tree[p].L==tree[p].R)return tree[p].mi; down(p); int mid=tree[p].L+tree[p].R&gt;&gt;1; if(x&lt;=mid)return query(x,p&lt;&lt;1); return query(x,p&lt;&lt;1|1); &#125;&#125;T;int main()&#123; Rd(k),Rd(n); for(int i=1,a,b,c,d,div;i&lt;=n;i++)&#123; Rd(a),Rd(b),Rd(c),Rd(d); div=gcd(a,b); a/=div,b/=div; div=gcd(c,d); c/=div,d/=div; tmp[++tot]=(Fr)&#123;b,a&#125;; num[i].L=tmp[tot]; tmp[++tot]=(Fr)&#123;d,c&#125;; num[i].R=tmp[tot]; &#125; sort(tmp+1,tmp+1+tot); tot=unique(tmp+1,tmp+1+tot)-tmp-1; T.build(1,tot,1); for(int i=1;i&lt;=n;i++)&#123; A[i].L=lower_bound(tmp+1,tmp+1+tot,num[i].L)-tmp; A[i].R=lower_bound(tmp+1,tmp+1+tot,num[i].R)-tmp; if(A[i].L&gt;A[i].R)swap(A[i].L,A[i].R); sum[A[i].L]++; sum[A[i].R+1]--; T.update(A[i].L,A[i].R,A[i].L,1); &#125; for(int i=1;i&lt;=tot;i++)&#123; sum[i]+=sum[i-1]; mi[i]=T.query(i,1); &#125; bool cur=0; for(int j=1;j&lt;=k;j++)&#123; cur^=1; memset(dp[cur],0,sizeof(dp[cur])); for(int i=1;i&lt;=tot;i++) dp[cur][i]=max(dp[cur^1][mi[i]-1]+sum[i],dp[cur][i-1]); &#125; cout&lt;&lt;dp[cur][tot]&lt;&lt;endl; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://YummyJay.github.io/tags/dp/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Polarization","slug":"POI2013 Polarization","date":"2016-10-09T11:38:44.000Z","updated":"2016-10-09T12:10:07.668Z","comments":true,"path":"2016/10/09/POI2013 Polarization/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Polarization/","excerpt":"POI2013 Polarization","text":"POI2013 Polarization 题目大意：给定一棵树，可以对每一条边定向成一个有向图，这张有向图的可达点对数为树上有路径从u到达v的点对(u,v)的个数。求最小可达点对数和最大可达点对数。 题解：最小值比较显然：首先一条边必然可以产生一个点对，那么可能存在的最小的可达点对数为n-1。接下来可以证明n-1必然可行：依层分别为树染色，奇层黑、偶层白，边只从黑点连向白点，那么可以发现只有n-1条边所对应的点对满足，从而可知，最小值为n-1。 最大值比较难，首先有一个结论: 一定以重心为根，任意一个子树要么全部指向根，要么全部背离根。 哪位神牛会证明，别忘了教我 设指向根的节点数为k1，背离的为k2，那么答案即为$\\sum (son_p -1) +k1 \\times k2$. $\\sum (son_p -1)$ 已经固定了，那么对答案贡献就看k1与k2了。 首先联想到的肯定是背包，定义dp[i]表示是否能有i个点指向根。之后考虑每一个点取不取。 但这样写复杂度并不能保证。如果遇到了“菊花图”，复杂度将退化为$O(n^2)$. 于是我们分块决策： 若某一个子树大小大于$\\sqrt{n}$ ,则直接背包。由于这样的子树不会超过$\\sqrt{n}$ 个，因而复杂度为$O(n \\sqrt{n})$. 另外小于$\\sqrt{n}$ 的部分，对二进制进行拆分，复杂度为$O(nlogn)$. 因而总复杂度为$O(n \\sqrt{n})$. 当然转移的部分可以用bitset来优化，复杂度为$O(\\frac{n \\sqrt{n}}{64})$. Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bitset&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=250001;int head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[N&lt;&lt;1];void add_edge(int a,int b)&#123; edge[++tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge;&#125;int n,son[N],mxson[N],heart;void find_heart(int p,int f)&#123; son[p]=1; for(int i=head[p];i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; find_heart(to,p); son[p]+=son[to]; mxson[p]=max(mxson[p],son[to]); &#125; mxson[p]=max(mxson[p],n-son[p]); if(!heart||mxson[heart]&gt;mxson[p])heart=p;&#125;int lim,cnt[505],num[505],tot;ll ans1,ans2;void dfs(int p,int f)&#123; son[p]=1; for(int i=head[p];i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; dfs(to,p); son[p]+=son[to]; &#125; if(heart==f)&#123; if(son[p]&lt;=lim)cnt[son[p]]++; else num[++tot]=son[p]; &#125; ans1+=son[p]-1;&#125;bitset&lt;N&gt;dp;int main()&#123; Rd(n); for(int i=1,a,b;i&lt;n;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); &#125; find_heart(1,0); while(lim*lim&lt;n)lim++; dfs(heart,0); dp[0]=1; while(tot)dp|=dp&lt;&lt;num[tot--]; for(int i=1;i&lt;=lim;i++)&#123; for(int j=cnt[i],k=1;j;j-=k,k&lt;&lt;=1)&#123; if(j&lt;=k)&#123; dp|=dp&lt;&lt;(i*j); break; &#125;else dp|=dp&lt;&lt;(i*k); &#125; &#125; for(int i=1;i&lt;=n;i++) if(dp[i])ans2=max(ans2,1LL*(n-1-i)*i); printf(\"%d %lld\\n\",n-1,ans1+ans2); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"},{"name":"树的重心","slug":"树的重心","permalink":"https://YummyJay.github.io/tags/树的重心/"},{"name":"背包","slug":"背包","permalink":"https://YummyJay.github.io/tags/背包/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Inspector","slug":"POI2013 Inspector","date":"2016-10-09T10:34:01.000Z","updated":"2016-10-09T11:22:37.140Z","comments":true,"path":"2016/10/09/POI2013 Inspector/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Inspector/","excerpt":"POI2013 Inspector","text":"POI2013 Inspector 题目大意：一天公司有n个员工和m个员工记录，每个员工只会在连续的一段时间内工作。当然写观察记录的时候肯定会在工作。记录会给出当时除了他还有多少人在公司。现在给出m条记录分别是谁写的、什么时候写的以及写的时候还有多少人。求第k条记录使得前k条记录可以同时存在不矛盾，且前k+1条记录是矛盾的。输出这个k。 $PS.$ 没有写出来，但似乎并不难。有些乱，但似乎只是乱搞就可以AC？最后还是去看了题解，在这里orz commoc，他的题解写的很好。 commoc的题解戳这儿 题解：一个很明显的思路是二分答案，把题目转化成判定性的问题，这样记录就没有先后顺序之分了。 重点是有关出现矛盾的判断: 记录本身的矛盾：两个记录在同一时刻，但人数不同。 这个可以直接特判，比较无脑。 记录的记载而产生约束关系形成了矛盾：比如某人在L时刻、R时刻都记录了东西，但L、R之间存在别人的一个记录，说除他外没有人了，这显然就有问题了。因为刚开始的那个人，在[L,R]之间是必然一直存在的。 这个也比较容易判断： 我们记录每一个人的最晚开始时间与最早结束时间，当成一条线段。对于每一个时间点，我们看看有多少条线段覆盖它。(这是当前时刻最少工作人数) 如果它大于当前时间点的记录人数，显然不可行。 可以构造出方案，但会超过n个人的限制。 这与上一条的区别在于它是可以满足约束条件的，但人数会超。 比如：1时刻有一个人记录有两个人，2时刻记录有1个人，3时刻记录有2个人。当n=3时显然是可以的，但n=2时显然不行。 首先我们想到，人数少是无所谓的，可以认为有些人一直未工作或不在记录的时间点上工作。 所以我们只要算出符合条件的最少人数，看是否小于等于n即可。 那么如何计算呢？ 令now表示当前必须在工作的人的数量，total表示当前最少符合的人数。 并令done表示所对应区间已经过去了，还可以留下来工作的人。 令notbegin表示所对应的区间已经过去，但还可以留下来工作的人。 每到达一个新的时刻，我们可以比较一下now+done+notbegin与tot[i] (这个点记录的人数) 的大小。 如果比tot[i] 小，说明人数还不够，我们需要再让一些人提前开始工作。 如果比tot[i] 大，那说明人数多了，我们就让done中的人结束工作，如果还是多，那就让notbegin中的人结束工作。 这时可能会有一个问题： notbegin的区间还没有开始，怎么可以结束工作呢？这样不相当于矛盾了么? 其实并不是，我们可以认为，我们去掉的是一个没有写过记录的人，他们没有记录，因而没有固定的区间，他们可以随时开始随时结束。(但他们也会被记录到total中) 这样一来，题目即可解决了。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=(int)1e5+1,inf=(int)1e9+7;int n,m,t[N],id[N],num[N],tot[N];int st[N],ed[N],mi[N],mx[N];bool judge(int lim)&#123; for(int i=1;i&lt;=n;i++) mi[i]=inf,mx[i]=-inf; for(int i=1;i&lt;=m;i++) tot[i]=st[i]=ed[i]=0; for(int i=1;i&lt;=lim;i++)&#123; if(tot[t[i]]&amp;&amp;tot[t[i]]!=num[i]+1)return false; tot[t[i]]=num[i]+1; mi[id[i]]=min(mi[id[i]],t[i]); mx[id[i]]=max(mx[id[i]],t[i]); &#125; for(int i=1;i&lt;=n;i++) if(mi[i]!=inf&amp;&amp;mx[i]!=-inf) st[mi[i]]++,ed[mx[i]]++; int now=0,total=0,notbegin=0,done=0; for(int i=1;i&lt;=m;i++)&#123; if(tot[i])&#123; now+=st[i]; if(now&gt;tot[i])return false; notbegin-=st[i]; if(notbegin&lt;0)total-=notbegin,notbegin=0; if(now+notbegin+done&lt;tot[i])total+=tot[i]-now-notbegin-done,notbegin=tot[i]-done-now; else&#123; if(now+notbegin&lt;=tot[i])done=tot[i]-notbegin-now; else notbegin=tot[i]-now,done=0; &#125; now-=ed[i],done+=ed[i]; &#125; &#125; if(total&gt;n)return false; return true;&#125;void solve()&#123; Rd(n),Rd(m); for(int i=1;i&lt;=m;i++) Rd(t[i]),Rd(id[i]),Rd(num[i]); int L=0,R=m,res=0; while(L&lt;=R)&#123; int mid=L+R&gt;&gt;1; if(judge(mid))&#123; res=mid; L=mid+1; &#125;else R=mid-1; &#125; printf(\"%d\\n\",res);&#125;int main()&#123; int cas;Rd(cas); for(;cas--;)solve(); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"},{"name":"二分","slug":"二分","permalink":"https://YummyJay.github.io/tags/二分/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Where is the one","slug":"POI2013 Where is the one","date":"2016-10-09T08:17:42.000Z","updated":"2016-10-09T08:41:19.551Z","comments":true,"path":"2016/10/09/POI2013 Where is the one/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Where is the one/","excerpt":"POI2013 Where is the one","text":"POI2013 Where is the one 题目大意：有一个1到n的排列，并且给你两个函数： f(i,j,d)：返回bool，表示d|(P[i]-P[j])是否成立。 g(i,j):返回P[i]是否比P[j]大. 你可以调用无限次f(只要不TLE)，以及尽量少的g。 最终来确定元素1的位置。 题解：我们可以发现，f函数可以用来判断，是否存在一个P[j]与P[i]的差值为d。 由于是一个排列，因而满足二分的性质： 以1为基准点，可以二分一个差值，并看看是否存在一个数与P[1]差值为d。 这样可以找到一个与P[1]相差最大的值的位置。(元素1或元素n) 再找到与它相差n-1的元素的位置。(元素1或元素n中的另一个) 最后调用一次g函数判断哪一个更小，那个就是元素1。 （注意特判n=1的情况） Code：123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include \"cgdzlib.h\"#include &lt;assert.h&gt;using namespace std;int id1,id2;bool judge(int cur)&#123; for(int i=2;i&lt;=n;i++) if(f(1,i,cur))&#123;id1=i;return true;&#125; return false;&#125;int main()&#123; n=inicjuj(); if(n==1)&#123; odpowiedz(1); return 0; &#125; int L=1,R=n-1; while(L&lt;=R)&#123; int mid=L+R&gt;&gt;1; if(judge(mid))L=mid+1; else R=mid-1; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i==id1)continue; if(f(id1,i,n-1))id2=i; &#125; if(g(id1,id2))odpowiedz(id2); else odpowiedz(id1); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://YummyJay.github.io/tags/二分/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Multidrink","slug":"POI2013 Multidrink","date":"2016-10-09T07:11:02.000Z","updated":"2016-10-09T08:05:12.330Z","comments":true,"path":"2016/10/09/POI2013 Multidrink/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Multidrink/","excerpt":"POI2013 Multidrink","text":"POI2013 Multidrink 题目大意：给一棵树，输出遍历序列a，要求每一个节点被访问到恰好一次，要求从1号节点出发，结束在n号节点，要求对于所有的$i$,a[i]与a[i+1]的距离小于等于2。 $PS.$ 完全没什么想法，只好去膜题解。在这里先orz Claris，若不是他的题解，我是写不出这题的。 给出Claris的题解链接 题解：以下的题解引用了Claris的内容 首先把1到n的路径取出来，作为主干。 定义毛毛虫为去掉叶子之后只有一条单链的树。 定义non_trivial的毛毛虫为单链非空的毛毛虫。 对于每一个主干上的点，计算它的非主干部分是否为毛毛虫，如果某一个部分不是毛毛虫，那么肯定无解。 接下来，我们将主干上的点划分为两类： A: non_trival的毛毛虫不超过一个。 B: non_trival的毛毛虫恰有两个。 同时定义一个点是free的，当且仅当它是单点。 如下图： 判断一下是否每一对相邻的B点中间都有free点，且所有的B点前后都有free点，如果没有那么也无解。 接下来，我们沿着主干依次走下来： (若在主干上，只能遍历A类点，只有不在主干点上时才能遍历B类点，但遍历完后又会回到主干点上。但此时若有一个free点，可以使它从主干上到非主干上。这也就是为什么两个B类点之间必须要有一个free点。并且由于起点终点都在主干上，因而B的前后都要有free点。) 若到了p这一层，并且主干点要求先遍历，且p不是free点：我们遍历p后，依次遍历每一个non_trivial毛毛虫，再遍历每一个triival毛毛虫，遍历完后，我们发现此时只能到下一层的主干点上去。 若到了p这一层，并且主干点要求先遍历，且p是free点：遍历完p后，我们可以跳到下一层的非主干点上，因为这样更优。 若到了p这一层，主干点不要求先遍历，且主干点为A类点：遍历每一个trivial毛毛虫，再遍历non_trivial，最后遍历p，并到下一层的非主干点上。 若到了p这一层，主干点不要求先遍历，且主干点为B类点：先遍历每一个trivial毛毛虫，再遍历一条non_trivial，之后借助主干点的缓冲，遍历另一条non_trivial 。但此时，到下一层只能到主干点上了。 接下来看看如何遍历一条毛毛虫(分两种:先遍历根，后遍历根) 将毛毛虫分层，并且将每层分为叶子节点和非叶子结点，根指的是第一层的非叶子结点。 若先遍历根，那么从1层开始一层一层过去，依次遍历奇数层的非叶子结点和偶数层的叶子节点，再反过来，往1层一层一层回来，依次遍历奇数层的叶子结点和偶数层的非叶子节点。 后遍历根与之相似，把奇偶换一下即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pb push_back#define sz(x) x.size()#define all(x) x.begin(),x.end()void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=500001;int n,head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[N&lt;&lt;1];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;int tot,dis[N],core[N];bool used[N];queue&lt;int&gt;Q;void SP()&#123; Q.push(1);used[1]=1;dis[1]=0; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(used[to])continue; Q.push(to); used[to]=true; dis[to]=dis[p]+1; &#125; &#125;memset(used,0,sizeof(used));&#125;void path(int p)&#123; used[p]=true;core[dis[p]+1]=p; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(dis[to]==dis[p]-1)&#123; path(to);break; &#125; &#125;&#125;#define NO puts(\"BRAK\"),exit(0)int son[N],md;bool is_ok[N];void dfs(int p,int f,int d)&#123; is_ok[p]=false;md=max(md,d); for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; is_ok[p]=true; dfs(to,p,d+1); son[p]+=is_ok[to]; &#125; if(son[p]&gt;=2)NO;&#125;struct Branch&#123; int id,flag; bool operator &lt;(const Branch&amp;tmp)const&#123; return flag&lt;tmp.flag; &#125;&#125;;vector&lt;Branch&gt;bra[N];bool fre[N],state[N];void manage(int p)&#123; fre[p]=true;int cnt=0; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(used[to])continue; fre[p]=false; md=0;dfs(to,p,0); if(md&lt;1)bra[p].pb((Branch)&#123;to,0&#125;); else bra[p].pb((Branch)&#123;to,1&#125;),cnt++; &#125; if(cnt&gt;2)NO; else if(cnt==2)state[p]=1; else state[p]=0;&#125;void init()&#123; memset(head,-1,sizeof(head)); Rd(n); for(int i=1,a,b;i&lt;n;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); &#125; SP();path(n);tot=dis[n]+1; for(int i=1;i&lt;=tot;i++) manage(core[i]);&#125;vector&lt;int&gt;num;void find(int p,int f)&#123; num.pb(p); for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; if(is_ok[to]&amp;&amp;!used[to])find(to,p); &#125;&#125;int ans[N],allc;void traverse(int p,int f)&#123; if(!is_ok[p])&#123;ans[++allc]=p;return;&#125; num.clear();find(p,0); for(int cas=0;cas&lt;sz(num);cas++)&#123; int cur=num[cas]; if(cas%2==f)&#123; for(int i=head[cur];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(!is_ok[to]&amp;&amp;!used[to])ans[++allc]=to; &#125; &#125;else ans[++allc]=cur; &#125; for(int cas=sz(num)-1;cas&gt;=0;cas--)&#123; int cur=num[cas]; if(cas%2==f)ans[++allc]=cur; else&#123; for(int i=head[cur];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(!is_ok[to]&amp;&amp;!used[to])ans[++allc]=to; &#125; &#125; &#125;&#125; void solve()&#123; bool ok=true; for(int i=1;i&lt;=tot;i++)&#123; int p=core[i]; if(ok&amp;&amp;state[p]==1)NO; if(ok&amp;&amp;!fre[p])&#123; ans[++allc]=p; sort(all(bra[p])); for(int j=sz(bra[p])-1;j&gt;=0;j--)traverse(bra[p][j].id,0); &#125;else if(ok&amp;&amp;fre[p])&#123; ans[++allc]=p; ok=false; &#125;else if(!ok&amp;&amp;!state[p])&#123; sort(all(bra[p])); for(int j=0;j&lt;sz(bra[p]);j++)traverse(bra[p][j].id,1); ans[++allc]=p; &#125;else&#123; sort(all(bra[p])); for(int j=0;j&lt;sz(bra[p])-1;j++)traverse(bra[p][j].id,1); ans[++allc]=p; traverse(bra[p][sz(bra[p])-1].id,0); ok=true; &#125; &#125;&#125;void Print()&#123; if(ans[allc]!=n)NO; for(int i=1;i&lt;=allc;i++) printf(\"%d\\n\",ans[i]);&#125;int main()&#123; init(); solve(); Print(); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://YummyJay.github.io/tags/构造/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Tower Defense game","slug":"POI2013 Tower Defense game","date":"2016-10-09T06:58:42.000Z","updated":"2016-10-09T07:05:34.339Z","comments":true,"path":"2016/10/09/POI2013 Tower Defense game/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Tower Defense game/","excerpt":"POI2013 Tower Defense game","text":"POI2013 Tower Defense game 题目大意：(来自BZOJ Jiry_2的翻译) 有一天XYW在4399上玩一个塔防游戏： 有n座城市由m条双向道路连接。XYW可以在城市中建防御塔，每一座防御塔可以保护它所在的城市以及和这座城市有道路直接连接的城市。 由于XYW比较蠢萌，他建了n座塔保卫了所有城市。 突然XYW的男人看到了他的电脑屏幕：我只要用k座塔就可以了。（保证存在仅用k座塔就可以保卫所有城市的情况） XYW不想被他的男人嘲笑，于是他就开始想如何用k座塔保护所有城市。 由于XYW比较蠢萌，他想不出来。 于是他更改了游戏规则：每一座塔可以保护和它所在城市最短距离在两条道路以内的所有城市。 请你给他一种用k座以内加强过的塔保护所有城市的方案。 题解:每次找一个没有被覆盖的点，在该城市上建塔，并覆盖。则一定可以得到一个有效的解。 证明也比较简单：题目保证用老版的塔可以得到解，那么这意味着在原版的方案中，每一个城市相邻至少有一个塔。那么我们把塔建在当前节点，既能够起到原塔的作用，又可以覆盖更大的范围，显然更优。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=(int)5e5+1,M=(int)2e6+1;int n,m,k,head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[M];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;bool used[N],is_build[N];struct Stack&#123; int num[N],tp; Stack()&#123; tp=0; &#125; void push(int v)&#123; num[tp++]=v; &#125; void pop()&#123; --tp; &#125; int top()&#123; return num[tp-1]; &#125; bool empty()&#123; return tp==0; &#125;&#125;stk;int main()&#123; Rd(n),Rd(m),Rd(k); for(int i=1;i&lt;=n;i++)head[i]=-1; for(int i=1,a,b;i&lt;=m;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); &#125; for(int i=1;i&lt;=n;i++)stk.push(i); int res=0; while(!stk.empty())&#123; int p=stk.top();stk.pop(); if(used[p])continue; is_build[p]=used[p]=true; res++; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; used[to]=true; for(int j=head[to];~j;j=edge[j].nxt)&#123; int nxt=edge[j].to; used[nxt]=true; &#125; &#125; &#125; printf(\"%d\\n\",res); for(int i=1;i&lt;=n;i++) if(is_build[i])printf(\"%d \",i); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Watering can","slug":"POI2013 Watering can","date":"2016-10-09T06:07:42.000Z","updated":"2016-10-09T06:29:48.662Z","comments":true,"path":"2016/10/09/POI2013 Watering can/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Watering can/","excerpt":"POI2013 Watering can","text":"POI2013 Watering can 题目大意：$PS.$罕见的数据结构题！！！ 有三类操作： void inicjuj(int n, int k, int *D)； 只在开头出现一次，给出序列的长度，一个指标k，以及维护的序列D。 void podlej(int a, int b)； 把D数组区间[a,b]都加1。 int dojrzale(int a, int b)； 询问区间[a,b]之间大于等于k的数有几个。 题解：我们用一个线段树来维护原有的序列，用一个bit维护已经大于等于k的数的序列。每进行一次操作二，就对[a,b]求最大值，若最大值大于等于k，说明这个数一直对答案有贡献，那么我们把线段树上的该点去掉(改成-inf，这样就不会被多次算到了)，并加入到bit中。询问时，直接在bit上区间询问即可。 由于每一个数只会被塞入bit一次，因而复杂度为$O((n+m)logn)$. Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int N=300001,inf=(int)1e9;int K,num[N];struct BIT&#123; #define lowbit(x) (x&amp;(-x)) int bit[N]; BIT()&#123; memset(bit,0,sizeof(bit)); &#125; void add(int x)&#123; for(;x&lt;N;x+=lowbit(x))bit[x]++; &#125; int sum(int x)&#123; int res=0; for(;x;x-=lowbit(x))res+=bit[x]; return res; &#125; int query(int L,int R)&#123; return sum(R)-sum(L-1); &#125;&#125;T;struct node&#123; int L,R,mx,id,add;&#125;tree[N&lt;&lt;2];struct Segment_Tree&#123; void up(int p)&#123; if(tree[p&lt;&lt;1].mx&gt;tree[p&lt;&lt;1|1].mx)tree[p].mx=tree[p&lt;&lt;1].mx,tree[p].id=tree[p&lt;&lt;1].id; else tree[p].mx=tree[p&lt;&lt;1|1].mx,tree[p].id=tree[p&lt;&lt;1|1].id; &#125; void down(int p)&#123; if(tree[p].add)&#123; tree[p&lt;&lt;1].mx+=tree[p].add; tree[p&lt;&lt;1|1].mx+=tree[p].add; tree[p&lt;&lt;1].add+=tree[p].add; tree[p&lt;&lt;1|1].add+=tree[p].add; tree[p].add=0; &#125; &#125; void build(int L,int R,int p)&#123; tree[p].L=L,tree[p].R=R,tree[p].add=0; if(L==R)&#123; tree[p].mx=num[L-1],tree[p].id=L-1; return; &#125; int mid=L+R&gt;&gt;1; build(L,mid,p&lt;&lt;1); build(mid+1,R,p&lt;&lt;1|1); up(p); &#125; void update(int L,int R,int p)&#123; if(tree[p].L==L&amp;&amp;tree[p].R==R)&#123; tree[p].mx++; tree[p].add++; return; &#125; down(p); int mid=tree[p].L+tree[p].R&gt;&gt;1; if(R&lt;=mid)update(L,R,p&lt;&lt;1); else if(L&gt;mid)update(L,R,p&lt;&lt;1|1); else update(L,mid,p&lt;&lt;1),update(mid+1,R,p&lt;&lt;1|1); up(p); &#125; void remove(int x,int p)&#123; if(tree[p].L==tree[p].R)&#123; tree[p].mx=-inf; return; &#125; down(p); int mid=tree[p].L+tree[p].R&gt;&gt;1; if(x&lt;=mid)remove(x,p&lt;&lt;1); else remove(x,p&lt;&lt;1|1); up(p); &#125; node query(int L,int R,int p)&#123; if(tree[p].L==L&amp;&amp;tree[p].R==R)return tree[p]; down(p); int mid=tree[p].L+tree[p].R&gt;&gt;1; if(R&lt;=mid)return query(L,R,p&lt;&lt;1); else if(L&gt;mid)return query(L,R,p&lt;&lt;1|1); else&#123; node Lson=query(L,mid,p&lt;&lt;1),Rson=query(mid+1,R,p&lt;&lt;1|1); if(Lson.mx&gt;Rson.mx)return Lson; return Rson; &#125; &#125;&#125;ST;void inicjuj(int n, int k, int *D)&#123; K=k; for(int i=0;i&lt;n;i++)&#123; num[i]=D[i]; if(num[i]&gt;=K)&#123; num[i]=-inf; T.add(i+1); &#125; &#125; ST.build(1,n,1);&#125;void podlej(int a, int b)&#123; ST.update(a+1,b+1,1); while(true)&#123; node cur=ST.query(a+1,b+1,1); if(cur.mx&gt;=K)&#123; ST.remove(cur.id+1,1); T.add(cur.id+1); &#125;else break; &#125;&#125;int dojrzale(int a, int b)&#123; return T.query(a+1,b+1);&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://YummyJay.github.io/tags/线段树/"},{"name":"BIT","slug":"BIT","permalink":"https://YummyJay.github.io/tags/BIT/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Colorful Chain","slug":"POI2013 Colorful Chain","date":"2016-10-09T05:59:29.000Z","updated":"2016-10-09T06:05:19.305Z","comments":true,"path":"2016/10/09/POI2013 Colorful Chain/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Colorful Chain/","excerpt":"POI2013 Colorful Chain","text":"POI2013 Colorful Chain 题目大意：给出一个序列p，问有多少个子串满足有$a_i$个$b_i$。 $PS.$ 感觉是做过来最简单的一道题，利用Hash随便$O(n)$扫过来即可。 但似乎不用快速读入能AC但只有99分？ Code：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int N=1000002,P=233;ull f[N],res;char buf[N*3*8],*p;void Rd(int&amp;res)&#123; for(++p;*p&lt;32;++p); for(res=0;*p&gt;47;++p)res=res*10+(*p^48);&#125;void Init()&#123; f[0]=1; for(int i=1;i&lt;N;i++)f[i]=f[i-1]*P; &#125;int n,m,num[N],a[N],tot;int main()&#123; Init(); p=buf-1; fread(buf,1,N*3*8,stdin); Rd(n),Rd(m); for(int i=1;i&lt;=m;i++)&#123; Rd(num[i]); tot+=num[i]; &#125; for(int i=1,p;i&lt;=m;i++)&#123; Rd(p); res+=f[p]*num[i]; &#125; int L=1,R=0,ans=0; ull cur=0; for(int i=1,p;i&lt;=n;i++)&#123; R++; Rd(a[i]); cur+=f[a[i]]; if(R-L+1&gt;tot)cur-=f[a[L++]]; if(cur==res)ans++; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"hash","slug":"hash","permalink":"https://YummyJay.github.io/tags/hash/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Take-out","slug":"POI2013 Take-out","date":"2016-10-09T05:40:45.000Z","updated":"2016-10-09T05:56:00.851Z","comments":true,"path":"2016/10/09/POI2013 Take-out/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Take-out/","excerpt":"POI2013 Take-out","text":"POI2013 Take-out 题目大意：有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件： 每次消除k+1个块，其中k块白色，一块黑色，并且这k+1块砖从开始到结束中间不能路过已经消除过的块。 $PS.$ 想法题啊。完全没有什么知识点 题解：我们把序列中的白色看成1，黑色看成-k。这样的话可以求一个前缀和，最近的两项前缀和相同的id，差一定为k+1。 于是我们利用一个栈，按顺序把前缀和推进去，每当新进来的元素和之前栈中某一元素权值相同，就把新来的元素连同两元素之间的元素全部弹出，作为一次操作。 接着，我们倒序输出操作即可。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1000001;int n,k,sum[N],tmp[N];char str[N];struct node&#123; int id,val;&#125;;int allc;struct Stack&#123; node num[N]; int tp; Stack()&#123; tp=0; &#125; bool empty()&#123; return tp==0; &#125; void push(node v)&#123; num[tp++]=v; &#125; void pop()&#123; tp--; &#125; node top()&#123; return num[tp-1]; &#125;&#125;stk;vector&lt;int&gt;ans[N];bool used[N];int main()&#123; scanf(\"%d%d%s\",&amp;n,&amp;k,str+1); for(int i=1;i&lt;=n;i++)&#123; if(str[i]=='b')sum[i]=sum[i-1]+1; else sum[i]=sum[i-1]-k; tmp[i]=sum[i]; &#125; sort(tmp+1,tmp+1+n); int len=unique(tmp+1,tmp+1+n)-tmp-1; for(int i=0;i&lt;=n;i++)sum[i]=lower_bound(tmp+1,tmp+1+len,sum[i])-tmp-1; for(int i=0;i&lt;=n;i++)&#123; if(used[sum[i]])&#123; ans[++allc].push_back(i); while(stk.top().val!=sum[i])&#123; used[stk.top().val]=false; ans[allc].push_back(stk.top().id),stk.pop(); &#125; &#125;else&#123; stk.push((node)&#123;i,sum[i]&#125;); used[sum[i]]=true; &#125; &#125; for(int i=allc;i&gt;=1;i--)&#123; for(int j=ans[i].size()-1;j&gt;=0;j--)&#123; printf(\"%d \",ans[i][j]); &#125;puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Taxis","slug":"POI2013 Taxis","date":"2016-10-09T03:27:01.000Z","updated":"2016-10-09T05:36:00.801Z","comments":true,"path":"2016/10/09/POI2013 Taxis/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Taxis/","excerpt":"POI2013 Taxis","text":"POI2013 Taxis 题目大意:你当前在0处，d处有一个车站，你的家在m处。你现在想坐出租车回家，但出租车只会从车站出发，并且第i辆车只被允许开$x_i$的距离(是路程，而不是位移)。问你回家最少要几辆出租车。 $PS.$ 比较简单的贪心题。 题解：有一个贪心思路比较显然：你在到达车站前，派出的车的$x_i$越大，我们所走的重复的路段越小。因而为了尽快到达d，我们可以直接按照$x_i$从大到小依次打车。 但这样却并不能保证我们能到家。因为我们可能为了用尽量少的车到d而把大的车都用完了，以至于没有一辆车能将你从d送到m去了。 那怎么办呢？我们发现，若你在d，只需要一辆$x_i&gt;=m-d$的车即可回家。因而一开始，我们给车排序后，先预留一辆大于等于m-d的最小的车。用其他的车先使自己到达d即可。 (有可能用其他的车可以直接到家，这样就不用加上预留的车的代价了) Code：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;void Rd(ll&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=500005;int n;ll m,d,num[N];int solve()&#123; sort(num+1,num+1+n); int id=lower_bound(num+1,num+1+n,m-d)-num; ll p=0;int cnt=0; for(int i=n;i&gt;=1;i--)&#123; if(i==id)continue; if(p&lt;d)&#123; if(num[i]&gt;d-p)&#123; p+=num[i]-d+p; cnt++; &#125;else break; &#125;else break; &#125; if(p&lt;d)&#123; if(num[id]&lt;m-p+d-p)return 0; else return cnt+1; &#125;else&#123; if(p&lt;m)return cnt+1; return cnt; &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;d&gt;&gt;n; for(int i=1;i&lt;=n;i++)Rd(num[i]); printf(\"%d\\n\",solve()); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://YummyJay.github.io/tags/贪心/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Triumphal arch","slug":"POI2013 Triumphal arch","date":"2016-10-09T02:59:25.000Z","updated":"2016-10-09T03:24:55.880Z","comments":true,"path":"2016/10/09/POI2013 Triumphal arch/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Triumphal arch/","excerpt":"POI2013 Triumphal arch","text":"POI2013 Triumphal arch 题目大意：有一棵树，1号节点已经被染黑，其余是白的。A、B两人轮流操作，一开始B在1号节点，A选择k个点染黑，然后B走一步。如果B能走到A没染的节点，则B获胜，否则若A染完全部的n个节点，则A获胜。求A能获胜的最小的k。 $PS.$ 比较显然的贪心。 题解：首先二分答案是很显然的，关键在于判定A能否获胜。 我是直接贪心来写的。 有一个很明显的思路：B在点i时，轮到B走，B的所有儿子都必须已经被染过，否则下一步A就会输。 那么定义sum[i]表示B在点i时，A染完i的所有儿子后，还剩下的染点个数。 若$sum[i]0$的那些点留出来的染色机会来协助i的染色。 于是我们从叶子节点往根一层一层遍历，如果当前节点染色次数不足，则向父亲要。(若父亲不够，则在遍历到它时，它又会向它的父亲要。) 最后，到根节点为止，根节点没有父亲因而无法向上要，因而我们就看根此时能否满足即可。 总的复杂度为$O(nlogn)$ 。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=300005;int head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[N&lt;&lt;1];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;int n,cnt[N],fa[N];ll sum[N];vector&lt;int&gt;num[N];void dfs(int p,int f,int d)&#123; num[d].push_back(p); fa[p]=f; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to!=f)dfs(to,p,d+1); &#125;&#125;bool judge(int mid)&#123; if(mid&lt;cnt[1])return false; memset(sum,0,sizeof(sum)); sum[1]=mid-cnt[1]; for(int d=1;d&lt;=n;d++)&#123; for(int i=0;i&lt;num[d].size();i++)&#123; int p=num[d][i]; int par=fa[p]; sum[p]=mid-cnt[p]+1; &#125; &#125; for(int d=n;d&gt;=1;d--)&#123; for(int i=0;i&lt;num[d].size();i++)&#123; int p=num[d][i]; int par=fa[p]; if(sum[p]&lt;0)&#123; sum[par]+=sum[p]; &#125; &#125; &#125; if(sum[1]&lt;0)return false; return true;&#125;int main()&#123; memset(head,-1,sizeof(head)); Rd(n); for(int i=1,a,b;i&lt;n;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); cnt[a]++,cnt[b]++; &#125; dfs(1,0,0); int L=0,R=n,res=-1; while(L&lt;=R)&#123; int mid=L+R&gt;&gt;1; if(judge(mid))&#123; res=mid; R=mid-1; &#125;else L=mid+1; &#125; printf(\"%d\\n\",res); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://YummyJay.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://YummyJay.github.io/tags/贪心/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Bytecomputer","slug":"POI2013 Bytecomputer","date":"2016-10-09T02:40:59.000Z","updated":"2016-10-09T02:55:49.572Z","comments":true,"path":"2016/10/09/POI2013 Bytecomputer/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Bytecomputer/","excerpt":"POI2013 Bytecomputer","text":"POI2013 Bytecomputer 题目大意:给定一个{-1,0,1}组成的序列,你可以进行$x[i]=x[i]+x[i-1]$这样的操作,求最少操作次数使其变成不降序列。 题解：首先猜测，从左往右依次过来，一定能够得到一组最优解。(哪位大神会证来教教我) 于是定义dp[i][j]表示到i为止，结尾为j的最小代价。 $O(n)​$ 暴力转移即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c;int k=1; while(c=getchar(),!isdigit(c)&amp;&amp;c!='-'); if(c=='-')k=-1,c=getchar(); do res=res*10+(c&amp;15); while(c=getchar(),isdigit(c)); res=res*k;&#125;const int N=1000005,inf=1&lt;&lt;30;int n,num[N],dp[3][N];int main()&#123; Rd(n); for(int i=1;i&lt;=n;i++)Rd(num[i]); if(num[1]==-1)dp[0][1]=0,dp[1][1]=dp[2][1]=inf; else if(num[1]==0)dp[1][1]=0,dp[0][1]=dp[2][1]=inf; else dp[2][1]=0,dp[0][1]=dp[1][1]=inf; for(int i=2;i&lt;=n;i++)&#123; if(num[i]==1)&#123; dp[2][i]=min(dp[0][i-1],min(dp[1][i-1],dp[2][i-1])); dp[1][i]=dp[0][i-1]+1; dp[0][i]=dp[0][i-1]+2; &#125;else if(num[i]==-1)&#123; dp[2][i]=dp[2][i-1]+2; dp[1][i]=inf; dp[0][i]=dp[0][i-1]; &#125;else&#123; dp[2][i]=dp[2][i-1]+1; dp[1][i]=min(dp[0][i-1],dp[1][i-1]); dp[0][i]=dp[0][i-1]+1; &#125; &#125; int ans=min(dp[0][n],min(dp[1][n],dp[2][n])); if(ans&gt;=inf)printf(\"BRAK\\n\"); else printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://YummyJay.github.io/tags/dp/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Tales of seafaring","slug":"POI2013 Tales of seafaring","date":"2016-10-09T02:07:23.000Z","updated":"2016-10-09T02:42:42.595Z","comments":true,"path":"2016/10/09/POI2013 Tales of seafaring/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Tales of seafaring/","excerpt":"POI2013 Tales of seafaring","text":"POI2013 Tales of seafaring 题目大意：一个n个点，m条边的无向图，每一条边的边权都为1。有k个询问，每次询问给出(s,t,d)，要求回答是否存在一条从s到t的路径，长度为d。(路径可以不必是简单路(可以自交)) $PS.$ 感觉不是很难，有点像想法题。 题解：仔细想想最后给的条件，不必是简单路意味着可以在两点之间来回走，从而有这么一个结论：若(s,t,d)可行，那么(s,t,d+2)也可行。(s不是孤立的点) 从而，思路就很简单了：找到s到t的最短奇路和最短偶路，根据询问d的奇偶性来与其中一个比较，若d比较大，说明我们可以利用来回走使其满足，否则不可行。 由于内存限制不能跑每一个点然后存下来，我们把询问离线处理，把起点相同的一起处理即可。 另外，此题还有一个小bug：若s是一个孤立的点，就不能够利用来回走来增加长度了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=5005,Q=1000005;int head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[N&lt;&lt;1];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;int n,m,k,sum[N];struct Query&#123; int s,t,d,id; bool operator &lt;(const Query&amp;tmp)const&#123; return s&lt;tmp.s; &#125;&#125;q[Q];bool ans[Q];int dis[2][N];struct node&#123; bool tag;int p;&#125;;queue&lt;node&gt;que;void BFS(int s)&#123; while(!que.empty())que.pop(); memset(dis,-1,sizeof(dis)); dis[0][s]=0,que.push((node)&#123;0,s&#125;); while(!que.empty())&#123; node cur=que.front();que.pop(); int p=cur.p;bool tag=cur.tag; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(dis[tag^1][to]==-1) dis[tag^1][to]=dis[tag][p]+1,que.push((node)&#123;tag^1,to&#125;); &#125; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); Rd(n),Rd(m),Rd(k); for(int i=1,a,b;i&lt;=m;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); sum[a]++,sum[b]++; &#125; for(int i=1;i&lt;=k;i++)&#123; Rd(q[i].s),Rd(q[i].t),Rd(q[i].d),q[i].id=i; &#125; sort(q+1,q+1+k); int cnt=0,ns; while(cnt&lt;k)&#123; ns=q[cnt+1].s; BFS(ns); while(cnt&lt;k&amp;&amp;q[cnt+1].s==ns)&#123; int id=q[cnt+1].id,t=q[cnt+1].t,d=q[cnt+1].d; bool tag=d%2; if(~dis[tag][t]&amp;&amp;(dis[tag][t]==d||dis[tag][t]&lt;d&amp;&amp;sum[t]))ans[id]=true; else ans[id]=false; cnt++; &#125; &#125; for(int i=1;i&lt;=k;i++)&#123; if(ans[i])printf(\"TAK\\n\"); else printf(\"NIE\\n\"); &#125; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://YummyJay.github.io/tags/最短路/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Price List","slug":"POI2013 Price List","date":"2016-10-08T14:36:14.000Z","updated":"2016-10-09T03:29:16.062Z","comments":true,"path":"2016/10/08/POI2013 Price List/","link":"","permalink":"https://YummyJay.github.io/2016/10/08/POI2013 Price List/","excerpt":"POI2013 Price List","text":"POI2013 Price List 题目大意：给定一个无向图，边权均为$a$，然后将原图中满足最短路等于$2a$的点对$(x,y)$之间再加一条边权为$b$的边。求$k$的单源最短路。 $PS.$各种乱搞，写不出来，只好膜题解。 题解：不难想到的是，最短路只会是以下几种情况： 直接在原图上走最短路。 原图最短路，每两条边合并成一个$b$。(若长度为奇数，还要补一个$a$) 如果按2中的方案走，长度为奇数的路径是要补$a$的，但倘若$a$很大的话，那就不划算了。因而可以在原图上找到一种稍长的、但可以保证完美缩成若干$b$的路线，这样反而可以更短。 前两种情况比较好处理，直接跑最短路就可以了。由于边权都是$a$，因而可以直接用$BFS$，此时的复杂度为$O(m)$. 但第三种情况就不太好搞了，但我们可以尝试先写出暴力。 也可以用$BFS$。 对于当前出队列的点$p$，先向外扫描一圈把与之相邻的节点标记掉。（表示这些节点不能从$p$转移到。）此时$dis_p$为偶数个$a$，因而相邻节点与$s$的最短路(这里指可以被分为若干个$b$的最短路)，是不可以从$p$转移过来的。 之后对于每一个相邻节点，再搜它们的相邻节点，没有被标记的，且未被更新过的$dis$的节点入队列，并更新其$dis$(由$p$更新，$p$到它的最短路为$2a$，可以将其缩为一个$b$)。 最后要把与$p$相邻的节点的标记去掉。(因为可能以后会有别的点可以来更新它) 这样即可达到我们想要的效果，复杂度为$O(m^2)$。 但这样显然过不了，我们考虑优化。 取出队列开头的$p$后，遍历与它相邻的点的过程，我们称之为一次遍历。然后再遍历第二波节点，我们称之为二次遍历。 当一次遍历到一个节点$pp$以后，并由$pp$扩展到下一个节点$to$时，我们发现$(pp,to)$这一条边在以后的二次遍历中再也没有用了。因为$to$已经进入了队列，而$pp$没有，也就是说$pp$还有机会成为一次遍历产生的点，这时再由它第二次遍历时，原来已经进入队列的$to$就不需要再次进入了，所以该边可以删掉。(这里的删掉只是指在二次遍历中删掉，一次遍历还可能用到这些边) 因而我们一次遍历用原图的边，二次遍历的边可以不停地删掉。 对于删边的操作，我们可以用双向链表来存边已达到效果。 接下来我们分析一下复杂度： 首先，时间复杂度约等于遍历边的数量，所以我们只需要考虑那些遍历了却没有删掉的边的数量。 对于每一个节点$x$，由它开始进行一次遍历、再二次遍历中，没被删掉的边只有一种，就是在二次遍历中遍历到了一个与$x$距离为1的点，也就是说形成了一个三元环。所以对于这个节点$x$，假设和它距离为1的点有$k$个，那么这次最多有$k^2$条边被遍历了但没有删掉。又因为总共的边数为m，所以总的时间复杂度为: $$\\sum_{v \\in{V}} min(degree(v^2),m) \\le \\sum_{v\\in{V}} \\sqrt{degree(v^2)*m} \\le \\sum_{v \\in {V}}degree(v)*\\sqrt{m}=O(m \\sqrt{m})$$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;/////////////////////////////////////////////////////////void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;/////////////////////////////////////////////////////////const int N=100001;/////////////////////////////////////////////////////////struct EDGE&#123; int tot_edge,head[N]; struct Edge&#123; int to,pre,nxt; &#125;edge[N&lt;&lt;1]; void add_edge(int a,int b)&#123; if(~head[a])edge[head[a]].pre=tot_edge; edge[tot_edge]=(Edge)&#123;b,-1,head[a]&#125;; head[a]=tot_edge++; &#125; void del_edge(int p,int id)&#123; if(id==head[p])head[p]=edge[id].nxt; if(~edge[id].nxt)edge[edge[id].nxt].pre=edge[id].pre; if(~edge[id].pre)edge[edge[id].pre].nxt=edge[id].nxt; &#125;&#125;E1,E2;/////////////////////////////////////////////////////////int n,m,s,A,B;/////////////////////////////////////////////////////////int dis[N];queue&lt;int&gt;Q;void BFS()&#123; while(!Q.empty())Q.pop(); memset(dis,-1,sizeof(dis)); dis[s]=0;Q.push(s); while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(int i=E1.head[p];~i;i=E1.edge[i].nxt)&#123; int to=E1.edge[i].to; if(dis[to]==-1)dis[to]=dis[p]+1,Q.push(to); &#125; &#125;&#125;/////////////////////////////////////////////////////////int dis1[N];bool mark[N];void BFS1()&#123; while(!Q.empty())Q.pop(); memset(dis1,-1,sizeof(dis1)); memset(mark,0,sizeof(mark)); dis1[s]=0;mark[s]=true;Q.push(s); while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(int i=E1.head[p];~i;i=E1.edge[i].nxt)&#123; int to=E1.edge[i].to; mark[to]=true; &#125; for(int i=E1.head[p];~i;i=E1.edge[i].nxt)&#123; int pp=E1.edge[i].to; for(int j=E2.head[pp];~j;j=E2.edge[j].nxt)&#123; int to=E2.edge[j].to; if(!mark[to]&amp;&amp;dis1[to]==-1)&#123; dis1[to]=dis1[p]+2; mark[to]=true; Q.push(to); E2.del_edge(pp,j); &#125; &#125; &#125; for(int i=E1.head[p];~i;i=E1.edge[i].nxt)&#123; int to=E1.edge[i].to; mark[to]=false; &#125; &#125;&#125;int main()&#123; memset(E1.head,-1,sizeof(E1.head)); memset(E2.head,-1,sizeof(E2.head)); Rd(n),Rd(m),Rd(s),Rd(A),Rd(B); for(int i=1,a,b;i&lt;=m;i++)&#123; Rd(a),Rd(b); E1.add_edge(a,b); E1.add_edge(b,a); E2.add_edge(a,b); E2.add_edge(b,a); &#125; BFS(); BFS1(); for(int i=1;i&lt;=n;i++)&#123; int res=1&lt;&lt;30; if(~dis[i])res=min(dis[i]/2*B+dis[i]%2*A,dis[i]*A); if(~dis1[i])res=min(res,dis1[i]/2*B); printf(\"%d\\n\",res); &#125; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://YummyJay.github.io/tags/最短路/"},{"name":"双向链表","slug":"双向链表","permalink":"https://YummyJay.github.io/tags/双向链表/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-10-08T12:00:00.000Z","updated":"2016-10-09T02:32:56.822Z","comments":true,"path":"2016/10/08/hello-world/","link":"","permalink":"https://YummyJay.github.io/2016/10/08/hello-world/","excerpt":"Hello World","text":"Hello World其实并不会搭博客，但在机房大神的帮助下还是搭了人生第一个博客。蛮喜欢这个主题，希望能够一直写下去。先来一发代码高亮：12345#include&lt;cstdio&gt;int main()&#123; puts(\"Hello World\"); return 0;&#125; Markdown其实也并不怎么会用，一边学一边写吧。","categories":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/categories/杂/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/tags/杂/"}],"keywords":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/categories/杂/"}]}]}