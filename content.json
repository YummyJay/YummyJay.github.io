{"meta":{"title":"YummyJay's archives","subtitle":null,"description":null,"author":"YummyJay","url":"https://YummyJay.github.io"},"pages":[{"title":"tags","date":"2016-10-09T01:52:27.000Z","updated":"2016-10-09T01:54:03.500Z","comments":true,"path":"tags/index.html","permalink":"https://YummyJay.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2016-10-09T01:54:39.000Z","updated":"2016-10-09T01:55:05.286Z","comments":true,"path":"categories/index.html","permalink":"https://YummyJay.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2016-10-09T01:55:32.000Z","updated":"2016-10-09T01:57:05.819Z","comments":true,"path":"about/index.html","permalink":"https://YummyJay.github.io/about/index.html","excerpt":"","text":"浙江蒟蒻一只。。。"}],"posts":[{"title":"POI2013 Polarization","slug":"POI2013 Polarization","date":"2016-10-09T11:38:44.000Z","updated":"2016-10-09T12:10:07.668Z","comments":true,"path":"2016/10/09/POI2013 Polarization/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Polarization/","excerpt":"POI2013 Polarization","text":"POI2013 Polarization 题目大意：给定一棵树，可以对每一条边定向成一个有向图，这张有向图的可达点对数为树上有路径从u到达v的点对(u,v)的个数。求最小可达点对数和最大可达点对数。 题解：最小值比较显然：首先一条边必然可以产生一个点对，那么可能存在的最小的可达点对数为n-1。接下来可以证明n-1必然可行：依层分别为树染色，奇层黑、偶层白，边只从黑点连向白点，那么可以发现只有n-1条边所对应的点对满足，从而可知，最小值为n-1。 最大值比较难，首先有一个结论: 一定以重心为根，任意一个子树要么全部指向根，要么全部背离根。 哪位神牛会证明，别忘了教我 设指向根的节点数为k1，背离的为k2，那么答案即为$\\sum (son_p -1) +k1 \\times k2$. $\\sum (son_p -1)$ 已经固定了，那么对答案贡献就看k1与k2了。 首先联想到的肯定是背包，定义dp[i]表示是否能有i个点指向根。之后考虑每一个点取不取。 但这样写复杂度并不能保证。如果遇到了“菊花图”，复杂度将退化为$O(n^2)$. 于是我们分块决策： 若某一个子树大小大于$\\sqrt{n}$ ,则直接背包。由于这样的子树不会超过$\\sqrt{n}$ 个，因而复杂度为$O(n \\sqrt{n})$. 另外小于$\\sqrt{n}$ 的部分，对二进制进行拆分，复杂度为$O(nlogn)$. 因而总复杂度为$O(n \\sqrt{n})$. 当然转移的部分可以用bitset来优化，复杂度为$O(\\frac{n \\sqrt{n}}{64})$. Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;bitset&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;typedef long long ll;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=250001;int head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[N&lt;&lt;1];void add_edge(int a,int b)&#123; edge[++tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge;&#125;int n,son[N],mxson[N],heart;void find_heart(int p,int f)&#123; son[p]=1; for(int i=head[p];i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; find_heart(to,p); son[p]+=son[to]; mxson[p]=max(mxson[p],son[to]); &#125; mxson[p]=max(mxson[p],n-son[p]); if(!heart||mxson[heart]&gt;mxson[p])heart=p;&#125;int lim,cnt[505],num[505],tot;ll ans1,ans2;void dfs(int p,int f)&#123; son[p]=1; for(int i=head[p];i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; dfs(to,p); son[p]+=son[to]; &#125; if(heart==f)&#123; if(son[p]&lt;=lim)cnt[son[p]]++; else num[++tot]=son[p]; &#125; ans1+=son[p]-1;&#125;bitset&lt;N&gt;dp;int main()&#123; Rd(n); for(int i=1,a,b;i&lt;n;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); &#125; find_heart(1,0); while(lim*lim&lt;n)lim++; dfs(heart,0); dp[0]=1; while(tot)dp|=dp&lt;&lt;num[tot--]; for(int i=1;i&lt;=lim;i++)&#123; for(int j=cnt[i],k=1;j;j-=k,k&lt;&lt;=1)&#123; if(j&lt;=k)&#123; dp|=dp&lt;&lt;(i*j); break; &#125;else dp|=dp&lt;&lt;(i*k); &#125; &#125; for(int i=1;i&lt;=n;i++) if(dp[i])ans2=max(ans2,1LL*(n-1-i)*i); printf(\"%d %lld\\n\",n-1,ans1+ans2); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"},{"name":"树的重心","slug":"树的重心","permalink":"https://YummyJay.github.io/tags/树的重心/"},{"name":"背包","slug":"背包","permalink":"https://YummyJay.github.io/tags/背包/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Inspector","slug":"POI2013 Inspector","date":"2016-10-09T10:34:01.000Z","updated":"2016-10-09T11:22:37.140Z","comments":true,"path":"2016/10/09/POI2013 Inspector/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Inspector/","excerpt":"POI2013 Inspector","text":"POI2013 Inspector 题目大意：一天公司有n个员工和m个员工记录，每个员工只会在连续的一段时间内工作。当然写观察记录的时候肯定会在工作。记录会给出当时除了他还有多少人在公司。现在给出m条记录分别是谁写的、什么时候写的以及写的时候还有多少人。求第k条记录使得前k条记录可以同时存在不矛盾，且前k+1条记录是矛盾的。输出这个k。 $PS.$ 没有写出来，但似乎并不难。有些乱，但似乎只是乱搞就可以AC？最后还是去看了题解，在这里orz commoc，他的题解写的很好。 commoc的题解戳这儿 题解：一个很明显的思路是二分答案，把题目转化成判定性的问题，这样记录就没有先后顺序之分了。 重点是有关出现矛盾的判断: 记录本身的矛盾：两个记录在同一时刻，但人数不同。 这个可以直接特判，比较无脑。 记录的记载而产生约束关系形成了矛盾：比如某人在L时刻、R时刻都记录了东西，但L、R之间存在别人的一个记录，说除他外没有人了，这显然就有问题了。因为刚开始的那个人，在[L,R]之间是必然一直存在的。 这个也比较容易判断： 我们记录每一个人的最晚开始时间与最早结束时间，当成一条线段。对于每一个时间点，我们看看有多少条线段覆盖它。(这是当前时刻最少工作人数) 如果它大于当前时间点的记录人数，显然不可行。 可以构造出方案，但会超过n个人的限制。 这与上一条的区别在于它是可以满足约束条件的，但人数会超。 比如：1时刻有一个人记录有两个人，2时刻记录有1个人，3时刻记录有2个人。当n=3时显然是可以的，但n=2时显然不行。 首先我们想到，人数少是无所谓的，可以认为有些人一直未工作或不在记录的时间点上工作。 所以我们只要算出符合条件的最少人数，看是否小于等于n即可。 那么如何计算呢？ 令now表示当前必须在工作的人的数量，total表示当前最少符合的人数。 并令done表示所对应区间已经过去了，还可以留下来工作的人。 令notbegin表示所对应的区间已经过去，但还可以留下来工作的人。 每到达一个新的时刻，我们可以比较一下now+done+notbegin与tot[i] (这个点记录的人数) 的大小。 如果比tot[i] 小，说明人数还不够，我们需要再让一些人提前开始工作。 如果比tot[i] 大，那说明人数多了，我们就让done中的人结束工作，如果还是多，那就让notbegin中的人结束工作。 这时可能会有一个问题： notbegin的区间还没有开始，怎么可以结束工作呢？这样不相当于矛盾了么? 其实并不是，我们可以认为，我们去掉的是一个没有写过记录的人，他们没有记录，因而没有固定的区间，他们可以随时开始随时结束。(但他们也会被记录到total中) 这样一来，题目即可解决了。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=(int)1e5+1,inf=(int)1e9+7;int n,m,t[N],id[N],num[N],tot[N];int st[N],ed[N],mi[N],mx[N];bool judge(int lim)&#123; for(int i=1;i&lt;=n;i++) mi[i]=inf,mx[i]=-inf; for(int i=1;i&lt;=m;i++) tot[i]=st[i]=ed[i]=0; for(int i=1;i&lt;=lim;i++)&#123; if(tot[t[i]]&amp;&amp;tot[t[i]]!=num[i]+1)return false; tot[t[i]]=num[i]+1; mi[id[i]]=min(mi[id[i]],t[i]); mx[id[i]]=max(mx[id[i]],t[i]); &#125; for(int i=1;i&lt;=n;i++) if(mi[i]!=inf&amp;&amp;mx[i]!=-inf) st[mi[i]]++,ed[mx[i]]++; int now=0,total=0,notbegin=0,done=0; for(int i=1;i&lt;=m;i++)&#123; if(tot[i])&#123; now+=st[i]; if(now&gt;tot[i])return false; notbegin-=st[i]; if(notbegin&lt;0)total-=notbegin,notbegin=0; if(now+notbegin+done&lt;tot[i])total+=tot[i]-now-notbegin-done,notbegin=tot[i]-done-now; else&#123; if(now+notbegin&lt;=tot[i])done=tot[i]-notbegin-now; else notbegin=tot[i]-now,done=0; &#125; now-=ed[i],done+=ed[i]; &#125; &#125; if(total&gt;n)return false; return true;&#125;void solve()&#123; Rd(n),Rd(m); for(int i=1;i&lt;=m;i++) Rd(t[i]),Rd(id[i]),Rd(num[i]); int L=0,R=m,res=0; while(L&lt;=R)&#123; int mid=L+R&gt;&gt;1; if(judge(mid))&#123; res=mid; L=mid+1; &#125;else R=mid-1; &#125; printf(\"%d\\n\",res);&#125;int main()&#123; int cas;Rd(cas); for(;cas--;)solve(); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://YummyJay.github.io/tags/二分/"},{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Where is the one","slug":"POI2013 Where is the one","date":"2016-10-09T08:17:42.000Z","updated":"2016-10-09T08:41:19.551Z","comments":true,"path":"2016/10/09/POI2013 Where is the one/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Where is the one/","excerpt":"POI2013 Where is the one","text":"POI2013 Where is the one 题目大意：有一个1到n的排列，并且给你两个函数： f(i,j,d)：返回bool，表示d|(P[i]-P[j])是否成立。 g(i,j):返回P[i]是否比P[j]大. 你可以调用无限次f(只要不TLE)，以及尽量少的g。 最终来确定元素1的位置。 题解：我们可以发现，f函数可以用来判断，是否存在一个P[j]与P[i]的差值为d。 由于是一个排列，因而满足二分的性质： 以1为基准点，可以二分一个差值，并看看是否存在一个数与P[1]差值为d。 这样可以找到一个与P[1]相差最大的值的位置。(元素1或元素n) 再找到与它相差n-1的元素的位置。(元素1或元素n中的另一个) 最后调用一次g函数判断哪一个更小，那个就是元素1。 （注意特判n=1的情况） Code：123456789101112131415161718192021222324252627282930313233#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;#include \"cgdzlib.h\"#include &lt;assert.h&gt;using namespace std;int id1,id2;bool judge(int cur)&#123; for(int i=2;i&lt;=n;i++) if(f(1,i,cur))&#123;id1=i;return true;&#125; return false;&#125;int main()&#123; n=inicjuj(); if(n==1)&#123; odpowiedz(1); return 0; &#125; int L=1,R=n-1; while(L&lt;=R)&#123; int mid=L+R&gt;&gt;1; if(judge(mid))L=mid+1; else R=mid-1; &#125; for(int i=1;i&lt;=n;i++)&#123; if(i==id1)continue; if(f(id1,i,n-1))id2=i; &#125; if(g(id1,id2))odpowiedz(id2); else odpowiedz(id1); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://YummyJay.github.io/tags/二分/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Multidrink","slug":"POI2013 Multidrink","date":"2016-10-09T07:11:02.000Z","updated":"2016-10-09T08:05:12.330Z","comments":true,"path":"2016/10/09/POI2013 Multidrink/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Multidrink/","excerpt":"POI2013 Multidrink","text":"POI2013 Multidrink 题目大意：给一棵树，输出遍历序列a，要求每一个节点被访问到恰好一次，要求从1号节点出发，结束在n号节点，要求对于所有的$i$,a[i]与a[i+1]的距离小于等于2。 $PS.$ 完全没什么想法，只好去膜题解。在这里先orz Claris，若不是他的题解，我是写不出这题的。 给出Claris的题解链接 题解：以下的题解引用了Claris的内容 首先把1到n的路径取出来，作为主干。 定义毛毛虫为去掉叶子之后只有一条单链的树。 定义non_trivial的毛毛虫为单链非空的毛毛虫。 对于每一个主干上的点，计算它的非主干部分是否为毛毛虫，如果某一个部分不是毛毛虫，那么肯定无解。 接下来，我们将主干上的点划分为两类： A: non_trival的毛毛虫不超过一个。 B: non_trival的毛毛虫恰有两个。 同时定义一个点是free的，当且仅当它是单点。 如下图： 判断一下是否每一对相邻的B点中间都有free点，且所有的B点前后都有free点，如果没有那么也无解。 接下来，我们沿着主干依次走下来： (若在主干上，只能遍历A类点，只有不在主干点上时才能遍历B类点，但遍历完后又会回到主干点上。但此时若有一个free点，可以使它从主干上到非主干上。这也就是为什么两个B类点之间必须要有一个free点。并且由于起点终点都在主干上，因而B的前后都要有free点。) 若到了p这一层，并且主干点要求先遍历，且p不是free点：我们遍历p后，依次遍历每一个non_trivial毛毛虫，再遍历每一个triival毛毛虫，遍历完后，我们发现此时只能到下一层的主干点上去。 若到了p这一层，并且主干点要求先遍历，且p是free点：遍历完p后，我们可以跳到下一层的非主干点上，因为这样更优。 若到了p这一层，主干点不要求先遍历，且主干点为A类点：遍历每一个trivial毛毛虫，再遍历non_trivial，最后遍历p，并到下一层的非主干点上。 若到了p这一层，主干点不要求先遍历，且主干点为B类点：先遍历每一个trivial毛毛虫，再遍历一条non_trivial，之后借助主干点的缓冲，遍历另一条non_trivial 。但此时，到下一层只能到主干点上了。 接下来看看如何遍历一条毛毛虫(分两种:先遍历根，后遍历根) 将毛毛虫分层，并且将每层分为叶子节点和非叶子结点，根指的是第一层的非叶子结点。 若先遍历根，那么从1层开始一层一层过去，依次遍历奇数层的非叶子结点和偶数层的叶子节点，再反过来，往1层一层一层回来，依次遍历奇数层的叶子结点和偶数层的非叶子节点。 后遍历根与之相似，把奇偶换一下即可。 Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167#include&lt;queue&gt;#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;#define pb push_back#define sz(x) x.size()#define all(x) x.begin(),x.end()void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=500001;int n,head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[N&lt;&lt;1];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;int tot,dis[N],core[N];bool used[N];queue&lt;int&gt;Q;void SP()&#123; Q.push(1);used[1]=1;dis[1]=0; while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(used[to])continue; Q.push(to); used[to]=true; dis[to]=dis[p]+1; &#125; &#125;memset(used,0,sizeof(used));&#125;void path(int p)&#123; used[p]=true;core[dis[p]+1]=p; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(dis[to]==dis[p]-1)&#123; path(to);break; &#125; &#125;&#125;#define NO puts(\"BRAK\"),exit(0)int son[N],md;bool is_ok[N];void dfs(int p,int f,int d)&#123; is_ok[p]=false;md=max(md,d); for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; is_ok[p]=true; dfs(to,p,d+1); son[p]+=is_ok[to]; &#125; if(son[p]&gt;=2)NO;&#125;struct Branch&#123; int id,flag; bool operator &lt;(const Branch&amp;tmp)const&#123; return flag&lt;tmp.flag; &#125;&#125;;vector&lt;Branch&gt;bra[N];bool fre[N],state[N];void manage(int p)&#123; fre[p]=true;int cnt=0; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(used[to])continue; fre[p]=false; md=0;dfs(to,p,0); if(md&lt;1)bra[p].pb((Branch)&#123;to,0&#125;); else bra[p].pb((Branch)&#123;to,1&#125;),cnt++; &#125; if(cnt&gt;2)NO; else if(cnt==2)state[p]=1; else state[p]=0;&#125;void init()&#123; memset(head,-1,sizeof(head)); Rd(n); for(int i=1,a,b;i&lt;n;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); &#125; SP();path(n);tot=dis[n]+1; for(int i=1;i&lt;=tot;i++) manage(core[i]);&#125;vector&lt;int&gt;num;void find(int p,int f)&#123; num.pb(p); for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to==f)continue; if(is_ok[to]&amp;&amp;!used[to])find(to,p); &#125;&#125;int ans[N],allc;void traverse(int p,int f)&#123; if(!is_ok[p])&#123;ans[++allc]=p;return;&#125; num.clear();find(p,0); for(int cas=0;cas&lt;sz(num);cas++)&#123; int cur=num[cas]; if(cas%2==f)&#123; for(int i=head[cur];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(!is_ok[to]&amp;&amp;!used[to])ans[++allc]=to; &#125; &#125;else ans[++allc]=cur; &#125; for(int cas=sz(num)-1;cas&gt;=0;cas--)&#123; int cur=num[cas]; if(cas%2==f)ans[++allc]=cur; else&#123; for(int i=head[cur];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(!is_ok[to]&amp;&amp;!used[to])ans[++allc]=to; &#125; &#125; &#125;&#125; void solve()&#123; bool ok=true; for(int i=1;i&lt;=tot;i++)&#123; int p=core[i]; if(ok&amp;&amp;state[p]==1)NO; if(ok&amp;&amp;!fre[p])&#123; ans[++allc]=p; sort(all(bra[p])); for(int j=sz(bra[p])-1;j&gt;=0;j--)traverse(bra[p][j].id,0); &#125;else if(ok&amp;&amp;fre[p])&#123; ans[++allc]=p; ok=false; &#125;else if(!ok&amp;&amp;!state[p])&#123; sort(all(bra[p])); for(int j=0;j&lt;sz(bra[p]);j++)traverse(bra[p][j].id,1); ans[++allc]=p; &#125;else&#123; sort(all(bra[p])); for(int j=0;j&lt;sz(bra[p])-1;j++)traverse(bra[p][j].id,1); ans[++allc]=p; traverse(bra[p][sz(bra[p])-1].id,0); ok=true; &#125; &#125;&#125;void Print()&#123; if(ans[allc]!=n)NO; for(int i=1;i&lt;=allc;i++) printf(\"%d\\n\",ans[i]);&#125;int main()&#123; init(); solve(); Print(); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"构造","slug":"构造","permalink":"https://YummyJay.github.io/tags/构造/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Tower Defense game","slug":"POI2013 Tower Defense game","date":"2016-10-09T06:58:42.000Z","updated":"2016-10-09T07:05:34.339Z","comments":true,"path":"2016/10/09/POI2013 Tower Defense game/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Tower Defense game/","excerpt":"POI2013 Tower Defense game","text":"POI2013 Tower Defense game 题目大意：(来自BZOJ Jiry_2的翻译) 有一天XYW在4399上玩一个塔防游戏： 有n座城市由m条双向道路连接。XYW可以在城市中建防御塔，每一座防御塔可以保护它所在的城市以及和这座城市有道路直接连接的城市。 由于XYW比较蠢萌，他建了n座塔保卫了所有城市。 突然XYW的男人看到了他的电脑屏幕：我只要用k座塔就可以了。（保证存在仅用k座塔就可以保卫所有城市的情况） XYW不想被他的男人嘲笑，于是他就开始想如何用k座塔保护所有城市。 由于XYW比较蠢萌，他想不出来。 于是他更改了游戏规则：每一座塔可以保护和它所在城市最短距离在两条道路以内的所有城市。 请你给他一种用k座以内加强过的塔保护所有城市的方案。 题解:每次找一个没有被覆盖的点，在该城市上建塔，并覆盖。则一定可以得到一个有效的解。 证明也比较简单：题目保证用老版的塔可以得到解，那么这意味着在原版的方案中，每一个城市相邻至少有一个塔。那么我们把塔建在当前节点，既能够起到原塔的作用，又可以覆盖更大的范围，显然更优。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;string.h&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=(int)5e5+1,M=(int)2e6+1;int n,m,k,head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[M];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;bool used[N],is_build[N];struct Stack&#123; int num[N],tp; Stack()&#123; tp=0; &#125; void push(int v)&#123; num[tp++]=v; &#125; void pop()&#123; --tp; &#125; int top()&#123; return num[tp-1]; &#125; bool empty()&#123; return tp==0; &#125;&#125;stk;int main()&#123; Rd(n),Rd(m),Rd(k); for(int i=1;i&lt;=n;i++)head[i]=-1; for(int i=1,a,b;i&lt;=m;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); &#125; for(int i=1;i&lt;=n;i++)stk.push(i); int res=0; while(!stk.empty())&#123; int p=stk.top();stk.pop(); if(used[p])continue; is_build[p]=used[p]=true; res++; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; used[to]=true; for(int j=head[to];~j;j=edge[j].nxt)&#123; int nxt=edge[j].to; used[nxt]=true; &#125; &#125; &#125; printf(\"%d\\n\",res); for(int i=1;i&lt;=n;i++) if(is_build[i])printf(\"%d \",i); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Watering can","slug":"POI2013 Watering can","date":"2016-10-09T06:07:42.000Z","updated":"2016-10-09T06:29:48.662Z","comments":true,"path":"2016/10/09/POI2013 Watering can/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Watering can/","excerpt":"POI2013 Watering can","text":"POI2013 Watering can 题目大意：$PS.$罕见的数据结构题！！！ 有三类操作： void inicjuj(int n, int k, int *D)； 只在开头出现一次，给出序列的长度，一个指标k，以及维护的序列D。 void podlej(int a, int b)； 把D数组区间[a,b]都加1。 int dojrzale(int a, int b)； 询问区间[a,b]之间大于等于k的数有几个。 题解：我们用一个线段树来维护原有的序列，用一个bit维护已经大于等于k的数的序列。每进行一次操作二，就对[a,b]求最大值，若最大值大于等于k，说明这个数一直对答案有贡献，那么我们把线段树上的该点去掉(改成-inf，这样就不会被多次算到了)，并加入到bit中。询问时，直接在bit上区间询问即可。 由于每一个数只会被塞入bit一次，因而复杂度为$O((n+m)logn)$. Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113#include&lt;string.h&gt;#include&lt;algorithm&gt;#include&lt;iostream&gt;using namespace std;const int N=300001,inf=(int)1e9;int K,num[N];struct BIT&#123; #define lowbit(x) (x&amp;(-x)) int bit[N]; BIT()&#123; memset(bit,0,sizeof(bit)); &#125; void add(int x)&#123; for(;x&lt;N;x+=lowbit(x))bit[x]++; &#125; int sum(int x)&#123; int res=0; for(;x;x-=lowbit(x))res+=bit[x]; return res; &#125; int query(int L,int R)&#123; return sum(R)-sum(L-1); &#125;&#125;T;struct node&#123; int L,R,mx,id,add;&#125;tree[N&lt;&lt;2];struct Segment_Tree&#123; void up(int p)&#123; if(tree[p&lt;&lt;1].mx&gt;tree[p&lt;&lt;1|1].mx)tree[p].mx=tree[p&lt;&lt;1].mx,tree[p].id=tree[p&lt;&lt;1].id; else tree[p].mx=tree[p&lt;&lt;1|1].mx,tree[p].id=tree[p&lt;&lt;1|1].id; &#125; void down(int p)&#123; if(tree[p].add)&#123; tree[p&lt;&lt;1].mx+=tree[p].add; tree[p&lt;&lt;1|1].mx+=tree[p].add; tree[p&lt;&lt;1].add+=tree[p].add; tree[p&lt;&lt;1|1].add+=tree[p].add; tree[p].add=0; &#125; &#125; void build(int L,int R,int p)&#123; tree[p].L=L,tree[p].R=R,tree[p].add=0; if(L==R)&#123; tree[p].mx=num[L-1],tree[p].id=L-1; return; &#125; int mid=L+R&gt;&gt;1; build(L,mid,p&lt;&lt;1); build(mid+1,R,p&lt;&lt;1|1); up(p); &#125; void update(int L,int R,int p)&#123; if(tree[p].L==L&amp;&amp;tree[p].R==R)&#123; tree[p].mx++; tree[p].add++; return; &#125; down(p); int mid=tree[p].L+tree[p].R&gt;&gt;1; if(R&lt;=mid)update(L,R,p&lt;&lt;1); else if(L&gt;mid)update(L,R,p&lt;&lt;1|1); else update(L,mid,p&lt;&lt;1),update(mid+1,R,p&lt;&lt;1|1); up(p); &#125; void remove(int x,int p)&#123; if(tree[p].L==tree[p].R)&#123; tree[p].mx=-inf; return; &#125; down(p); int mid=tree[p].L+tree[p].R&gt;&gt;1; if(x&lt;=mid)remove(x,p&lt;&lt;1); else remove(x,p&lt;&lt;1|1); up(p); &#125; node query(int L,int R,int p)&#123; if(tree[p].L==L&amp;&amp;tree[p].R==R)return tree[p]; down(p); int mid=tree[p].L+tree[p].R&gt;&gt;1; if(R&lt;=mid)return query(L,R,p&lt;&lt;1); else if(L&gt;mid)return query(L,R,p&lt;&lt;1|1); else&#123; node Lson=query(L,mid,p&lt;&lt;1),Rson=query(mid+1,R,p&lt;&lt;1|1); if(Lson.mx&gt;Rson.mx)return Lson; return Rson; &#125; &#125;&#125;ST;void inicjuj(int n, int k, int *D)&#123; K=k; for(int i=0;i&lt;n;i++)&#123; num[i]=D[i]; if(num[i]&gt;=K)&#123; num[i]=-inf; T.add(i+1); &#125; &#125; ST.build(1,n,1);&#125;void podlej(int a, int b)&#123; ST.update(a+1,b+1,1); while(true)&#123; node cur=ST.query(a+1,b+1,1); if(cur.mx&gt;=K)&#123; ST.remove(cur.id+1,1); T.add(cur.id+1); &#125;else break; &#125;&#125;int dojrzale(int a, int b)&#123; return T.query(a+1,b+1);&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"https://YummyJay.github.io/tags/线段树/"},{"name":"BIT","slug":"BIT","permalink":"https://YummyJay.github.io/tags/BIT/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Colorful Chain","slug":"POI2013 Colorful Chain","date":"2016-10-09T05:59:29.000Z","updated":"2016-10-09T06:05:19.305Z","comments":true,"path":"2016/10/09/POI2013 Colorful Chain/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Colorful Chain/","excerpt":"POI2013 Colorful Chain","text":"POI2013 Colorful Chain 题目大意：给出一个序列p，问有多少个子串满足有$a_i$个$b_i$。 $PS.$ 感觉是做过来最简单的一道题，利用Hash随便$O(n)$扫过来即可。 但似乎不用快速读入能AC但只有99分？ Code：12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int N=1000002,P=233;ull f[N],res;char buf[N*3*8],*p;void Rd(int&amp;res)&#123; for(++p;*p&lt;32;++p); for(res=0;*p&gt;47;++p)res=res*10+(*p^48);&#125;void Init()&#123; f[0]=1; for(int i=1;i&lt;N;i++)f[i]=f[i-1]*P; &#125;int n,m,num[N],a[N],tot;int main()&#123; Init(); p=buf-1; fread(buf,1,N*3*8,stdin); Rd(n),Rd(m); for(int i=1;i&lt;=m;i++)&#123; Rd(num[i]); tot+=num[i]; &#125; for(int i=1,p;i&lt;=m;i++)&#123; Rd(p); res+=f[p]*num[i]; &#125; int L=1,R=0,ans=0; ull cur=0; for(int i=1,p;i&lt;=n;i++)&#123; R++; Rd(a[i]); cur+=f[a[i]]; if(R-L+1&gt;tot)cur-=f[a[L++]]; if(cur==res)ans++; &#125; printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"hash","slug":"hash","permalink":"https://YummyJay.github.io/tags/hash/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Take-out","slug":"POI2013 Take-out","date":"2016-10-09T05:40:45.000Z","updated":"2016-10-09T05:56:00.851Z","comments":true,"path":"2016/10/09/POI2013 Take-out/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Take-out/","excerpt":"POI2013 Take-out","text":"POI2013 Take-out 题目大意：有n块砖，其中白色是黑色的k倍，求一个消除序列，满足以下条件： 每次消除k+1个块，其中k块白色，一块黑色，并且这k+1块砖从开始到结束中间不能路过已经消除过的块。 $PS.$ 想法题啊。完全没有什么知识点 题解：我们把序列中的白色看成1，黑色看成-k。这样的话可以求一个前缀和，最近的两项前缀和相同的id，差一定为k+1。 于是我们利用一个栈，按顺序把前缀和推进去，每当新进来的元素和之前栈中某一元素权值相同，就把新来的元素连同两元素之间的元素全部弹出，作为一次操作。 接着，我们倒序输出操作即可。 Code：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N=1000001;int n,k,sum[N],tmp[N];char str[N];struct node&#123; int id,val;&#125;;int allc;struct Stack&#123; node num[N]; int tp; Stack()&#123; tp=0; &#125; bool empty()&#123; return tp==0; &#125; void push(node v)&#123; num[tp++]=v; &#125; void pop()&#123; tp--; &#125; node top()&#123; return num[tp-1]; &#125;&#125;stk;vector&lt;int&gt;ans[N];bool used[N];int main()&#123; scanf(\"%d%d%s\",&amp;n,&amp;k,str+1); for(int i=1;i&lt;=n;i++)&#123; if(str[i]=='b')sum[i]=sum[i-1]+1; else sum[i]=sum[i-1]-k; tmp[i]=sum[i]; &#125; sort(tmp+1,tmp+1+n); int len=unique(tmp+1,tmp+1+n)-tmp-1; for(int i=0;i&lt;=n;i++)sum[i]=lower_bound(tmp+1,tmp+1+len,sum[i])-tmp-1; for(int i=0;i&lt;=n;i++)&#123; if(used[sum[i]])&#123; ans[++allc].push_back(i); while(stk.top().val!=sum[i])&#123; used[stk.top().val]=false; ans[allc].push_back(stk.top().id),stk.pop(); &#125; &#125;else&#123; stk.push((node)&#123;i,sum[i]&#125;); used[sum[i]]=true; &#125; &#125; for(int i=allc;i&gt;=1;i--)&#123; for(int j=ans[i].size()-1;j&gt;=0;j--)&#123; printf(\"%d \",ans[i][j]); &#125;puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://YummyJay.github.io/tags/想法/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Taxis","slug":"POI2013 Taxis","date":"2016-10-09T03:27:01.000Z","updated":"2016-10-09T05:36:00.801Z","comments":true,"path":"2016/10/09/POI2013 Taxis/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Taxis/","excerpt":"POI2013 Taxis","text":"POI2013 Taxis 题目大意:你当前在0处，d处有一个车站，你的家在m处。你现在想坐出租车回家，但出租车只会从车站出发，并且第i辆车只被允许开$x_i$的距离(是路程，而不是位移)。问你回家最少要几辆出租车。 $PS.$ 比较简单的贪心题。 题解：有一个贪心思路比较显然：你在到达车站前，派出的车的$x_i$越大，我们所走的重复的路段越小。因而为了尽快到达d，我们可以直接按照$x_i$从大到小依次打车。 但这样却并不能保证我们能到家。因为我们可能为了用尽量少的车到d而把大的车都用完了，以至于没有一辆车能将你从d送到m去了。 那怎么办呢？我们发现，若你在d，只需要一辆$x_i&gt;=m-d$的车即可回家。因而一开始，我们给车排序后，先预留一辆大于等于m-d的最小的车。用其他的车先使自己到达d即可。 (有可能用其他的车可以直接到家，这样就不用加上预留的车的代价了) Code：123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;void Rd(ll&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=500005;int n;ll m,d,num[N];int solve()&#123; sort(num+1,num+1+n); int id=lower_bound(num+1,num+1+n,m-d)-num; ll p=0;int cnt=0; for(int i=n;i&gt;=1;i--)&#123; if(i==id)continue; if(p&lt;d)&#123; if(num[i]&gt;d-p)&#123; p+=num[i]-d+p; cnt++; &#125;else break; &#125;else break; &#125; if(p&lt;d)&#123; if(num[id]&lt;m-p+d-p)return 0; else return cnt+1; &#125;else&#123; if(p&lt;m)return cnt+1; return cnt; &#125;&#125;int main()&#123; cin&gt;&gt;m&gt;&gt;d&gt;&gt;n; for(int i=1;i&lt;=n;i++)Rd(num[i]); printf(\"%d\\n\",solve()); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"https://YummyJay.github.io/tags/贪心/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Triumphal arch","slug":"POI2013 Triumphal arch","date":"2016-10-09T02:59:25.000Z","updated":"2016-10-09T03:24:55.880Z","comments":true,"path":"2016/10/09/POI2013 Triumphal arch/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Triumphal arch/","excerpt":"POI2013 Triumphal arch","text":"POI2013 Triumphal arch 题目大意：有一棵树，1号节点已经被染黑，其余是白的。A、B两人轮流操作，一开始B在1号节点，A选择k个点染黑，然后B走一步。如果B能走到A没染的节点，则B获胜，否则若A染完全部的n个节点，则A获胜。求A能获胜的最小的k。 $PS.$ 比较显然的贪心。 题解：首先二分答案是很显然的，关键在于判定A能否获胜。 我是直接贪心来写的。 有一个很明显的思路：B在点i时，轮到B走，B的所有儿子都必须已经被染过，否则下一步A就会输。 那么定义sum[i]表示B在点i时，A染完i的所有儿子后，还剩下的染点个数。 若$sum[i]0$的那些点留出来的染色机会来协助i的染色。 于是我们从叶子节点往根一层一层遍历，如果当前节点染色次数不足，则向父亲要。(若父亲不够，则在遍历到它时，它又会向它的父亲要。) 最后，到根节点为止，根节点没有父亲因而无法向上要，因而我们就看根此时能否满足即可。 总的复杂度为$O(nlogn)$ 。 Code：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;vector&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=300005;int head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[N&lt;&lt;1];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;int n,cnt[N],fa[N];ll sum[N];vector&lt;int&gt;num[N];void dfs(int p,int f,int d)&#123; num[d].push_back(p); fa[p]=f; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(to!=f)dfs(to,p,d+1); &#125;&#125;bool judge(int mid)&#123; if(mid&lt;cnt[1])return false; memset(sum,0,sizeof(sum)); sum[1]=mid-cnt[1]; for(int d=1;d&lt;=n;d++)&#123; for(int i=0;i&lt;num[d].size();i++)&#123; int p=num[d][i]; int par=fa[p]; sum[p]=mid-cnt[p]+1; &#125; &#125; for(int d=n;d&gt;=1;d--)&#123; for(int i=0;i&lt;num[d].size();i++)&#123; int p=num[d][i]; int par=fa[p]; if(sum[p]&lt;0)&#123; sum[par]+=sum[p]; &#125; &#125; &#125; if(sum[1]&lt;0)return false; return true;&#125;int main()&#123; memset(head,-1,sizeof(head)); Rd(n); for(int i=1,a,b;i&lt;n;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); cnt[a]++,cnt[b]++; &#125; dfs(1,0,0); int L=0,R=n,res=-1; while(L&lt;=R)&#123; int mid=L+R&gt;&gt;1; if(judge(mid))&#123; res=mid; R=mid-1; &#125;else L=mid+1; &#125; printf(\"%d\\n\",res); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"二分","slug":"二分","permalink":"https://YummyJay.github.io/tags/二分/"},{"name":"贪心","slug":"贪心","permalink":"https://YummyJay.github.io/tags/贪心/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Bytecomputer","slug":"POI2013 Bytecomputer","date":"2016-10-09T02:40:59.000Z","updated":"2016-10-09T02:55:49.572Z","comments":true,"path":"2016/10/09/POI2013 Bytecomputer/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Bytecomputer/","excerpt":"POI2013 Bytecomputer","text":"POI2013 Bytecomputer 题目大意:给定一个{-1,0,1}组成的序列,你可以进行$x[i]=x[i]+x[i-1]$这样的操作,求最少操作次数使其变成不降序列。 题解：首先猜测，从左往右依次过来，一定能够得到一组最优解。(哪位大神会证来教教我) 于是定义dp[i][j]表示到i为止，结尾为j的最小代价。 $O(n)​$ 暴力转移即可。 Code:1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c;int k=1; while(c=getchar(),!isdigit(c)&amp;&amp;c!='-'); if(c=='-')k=-1,c=getchar(); do res=res*10+(c&amp;15); while(c=getchar(),isdigit(c)); res=res*k;&#125;const int N=1000005,inf=1&lt;&lt;30;int n,num[N],dp[3][N];int main()&#123; Rd(n); for(int i=1;i&lt;=n;i++)Rd(num[i]); if(num[1]==-1)dp[0][1]=0,dp[1][1]=dp[2][1]=inf; else if(num[1]==0)dp[1][1]=0,dp[0][1]=dp[2][1]=inf; else dp[2][1]=0,dp[0][1]=dp[1][1]=inf; for(int i=2;i&lt;=n;i++)&#123; if(num[i]==1)&#123; dp[2][i]=min(dp[0][i-1],min(dp[1][i-1],dp[2][i-1])); dp[1][i]=dp[0][i-1]+1; dp[0][i]=dp[0][i-1]+2; &#125;else if(num[i]==-1)&#123; dp[2][i]=dp[2][i-1]+2; dp[1][i]=inf; dp[0][i]=dp[0][i-1]; &#125;else&#123; dp[2][i]=dp[2][i-1]+1; dp[1][i]=min(dp[0][i-1],dp[1][i-1]); dp[0][i]=dp[0][i-1]+1; &#125; &#125; int ans=min(dp[0][n],min(dp[1][n],dp[2][n])); if(ans&gt;=inf)printf(\"BRAK\\n\"); else printf(\"%d\\n\",ans); return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"dp","slug":"dp","permalink":"https://YummyJay.github.io/tags/dp/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Tales of seafaring","slug":"POI2013 Tales of seafaring","date":"2016-10-09T02:07:23.000Z","updated":"2016-10-09T02:42:42.595Z","comments":true,"path":"2016/10/09/POI2013 Tales of seafaring/","link":"","permalink":"https://YummyJay.github.io/2016/10/09/POI2013 Tales of seafaring/","excerpt":"POI2013 Tales of seafaring","text":"POI2013 Tales of seafaring 题目大意：一个n个点，m条边的无向图，每一条边的边权都为1。有k个询问，每次询问给出(s,t,d)，要求回答是否存在一条从s到t的路径，长度为d。(路径可以不必是简单路(可以自交)) $PS.$ 感觉不是很难，有点像想法题。 题解：仔细想想最后给的条件，不必是简单路意味着可以在两点之间来回走，从而有这么一个结论：若(s,t,d)可行，那么(s,t,d+2)也可行。(s不是孤立的点) 从而，思路就很简单了：找到s到t的最短奇路和最短偶路，根据询问d的奇偶性来与其中一个比较，若d比较大，说明我们可以利用来回走使其满足，否则不可行。 由于内存限制不能跑每一个点然后存下来，我们把询问离线处理，把起点相同的一起处理即可。 另外，此题还有一个小bug：若s是一个孤立的点，就不能够利用来回走来增加长度了。 Code:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;const int N=5005,Q=1000005;int head[N],tot_edge;struct Edge&#123; int to,nxt;&#125;edge[N&lt;&lt;1];void add_edge(int a,int b)&#123; edge[tot_edge]=(Edge)&#123;b,head[a]&#125;; head[a]=tot_edge++;&#125;int n,m,k,sum[N];struct Query&#123; int s,t,d,id; bool operator &lt;(const Query&amp;tmp)const&#123; return s&lt;tmp.s; &#125;&#125;q[Q];bool ans[Q];int dis[2][N];struct node&#123; bool tag;int p;&#125;;queue&lt;node&gt;que;void BFS(int s)&#123; while(!que.empty())que.pop(); memset(dis,-1,sizeof(dis)); dis[0][s]=0,que.push((node)&#123;0,s&#125;); while(!que.empty())&#123; node cur=que.front();que.pop(); int p=cur.p;bool tag=cur.tag; for(int i=head[p];~i;i=edge[i].nxt)&#123; int to=edge[i].to; if(dis[tag^1][to]==-1) dis[tag^1][to]=dis[tag][p]+1,que.push((node)&#123;tag^1,to&#125;); &#125; &#125;&#125;int main()&#123; memset(head,-1,sizeof(head)); Rd(n),Rd(m),Rd(k); for(int i=1,a,b;i&lt;=m;i++)&#123; Rd(a),Rd(b); add_edge(a,b); add_edge(b,a); sum[a]++,sum[b]++; &#125; for(int i=1;i&lt;=k;i++)&#123; Rd(q[i].s),Rd(q[i].t),Rd(q[i].d),q[i].id=i; &#125; sort(q+1,q+1+k); int cnt=0,ns; while(cnt&lt;k)&#123; ns=q[cnt+1].s; BFS(ns); while(cnt&lt;k&amp;&amp;q[cnt+1].s==ns)&#123; int id=q[cnt+1].id,t=q[cnt+1].t,d=q[cnt+1].d; bool tag=d%2; if(~dis[tag][t]&amp;&amp;(dis[tag][t]==d||dis[tag][t]&lt;d&amp;&amp;sum[t]))ans[id]=true; else ans[id]=false; cnt++; &#125; &#125; for(int i=1;i&lt;=k;i++)&#123; if(ans[i])printf(\"TAK\\n\"); else printf(\"NIE\\n\"); &#125; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://YummyJay.github.io/tags/最短路/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"POI2013 Price List","slug":"POI2013 Price List","date":"2016-10-08T14:36:14.000Z","updated":"2016-10-09T03:29:16.062Z","comments":true,"path":"2016/10/08/POI2013 Price List/","link":"","permalink":"https://YummyJay.github.io/2016/10/08/POI2013 Price List/","excerpt":"POI2013 Price List","text":"POI2013 Price List 题目大意：给定一个无向图，边权均为$a$，然后将原图中满足最短路等于$2a$的点对$(x,y)$之间再加一条边权为$b$的边。求$k$的单源最短路。 $PS.$各种乱搞，写不出来，只好膜题解。 题解：不难想到的是，最短路只会是以下几种情况： 直接在原图上走最短路。 原图最短路，每两条边合并成一个$b$。(若长度为奇数，还要补一个$a$) 如果按2中的方案走，长度为奇数的路径是要补$a$的，但倘若$a$很大的话，那就不划算了。因而可以在原图上找到一种稍长的、但可以保证完美缩成若干$b$的路线，这样反而可以更短。 前两种情况比较好处理，直接跑最短路就可以了。由于边权都是$a$，因而可以直接用$BFS$，此时的复杂度为$O(m)$. 但第三种情况就不太好搞了，但我们可以尝试先写出暴力。 也可以用$BFS$。 对于当前出队列的点$p$，先向外扫描一圈把与之相邻的节点标记掉。（表示这些节点不能从$p$转移到。）此时$dis_p$为偶数个$a$，因而相邻节点与$s$的最短路(这里指可以被分为若干个$b$的最短路)，是不可以从$p$转移过来的。 之后对于每一个相邻节点，再搜它们的相邻节点，没有被标记的，且未被更新过的$dis$的节点入队列，并更新其$dis$(由$p$更新，$p$到它的最短路为$2a$，可以将其缩为一个$b$)。 最后要把与$p$相邻的节点的标记去掉。(因为可能以后会有别的点可以来更新它) 这样即可达到我们想要的效果，复杂度为$O(m^2)$。 但这样显然过不了，我们考虑优化。 取出队列开头的$p$后，遍历与它相邻的点的过程，我们称之为一次遍历。然后再遍历第二波节点，我们称之为二次遍历。 当一次遍历到一个节点$pp$以后，并由$pp$扩展到下一个节点$to$时，我们发现$(pp,to)$这一条边在以后的二次遍历中再也没有用了。因为$to$已经进入了队列，而$pp$没有，也就是说$pp$还有机会成为一次遍历产生的点，这时再由它第二次遍历时，原来已经进入队列的$to$就不需要再次进入了，所以该边可以删掉。(这里的删掉只是指在二次遍历中删掉，一次遍历还可能用到这些边) 因而我们一次遍历用原图的边，二次遍历的边可以不停地删掉。 对于删边的操作，我们可以用双向链表来存边已达到效果。 接下来我们分析一下复杂度： 首先，时间复杂度约等于遍历边的数量，所以我们只需要考虑那些遍历了却没有删掉的边的数量。 对于每一个节点$x$，由它开始进行一次遍历、再二次遍历中，没被删掉的边只有一种，就是在二次遍历中遍历到了一个与$x$距离为1的点，也就是说形成了一个三元环。所以对于这个节点$x$，假设和它距离为1的点有$k$个，那么这次最多有$k^2$条边被遍历了但没有删掉。又因为总共的边数为m，所以总的时间复杂度为: $$\\sum_{v \\in{V}} min(degree(v^2),m) \\le \\sum_{v\\in{V}} \\sqrt{degree(v^2)*m} \\le \\sum_{v \\in {V}}degree(v)*\\sqrt{m}=O(m \\sqrt{m})$$ Code:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;queue&gt;#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;/////////////////////////////////////////////////////////void Rd(int&amp;res)&#123; res=0;char c; while(c=getchar(),c&lt;48); do res=res*10+(c&amp;15); while(c=getchar(),c&gt;47);&#125;/////////////////////////////////////////////////////////const int N=100001;/////////////////////////////////////////////////////////struct EDGE&#123; int tot_edge,head[N]; struct Edge&#123; int to,pre,nxt; &#125;edge[N&lt;&lt;1]; void add_edge(int a,int b)&#123; if(~head[a])edge[head[a]].pre=tot_edge; edge[tot_edge]=(Edge)&#123;b,-1,head[a]&#125;; head[a]=tot_edge++; &#125; void del_edge(int p,int id)&#123; if(id==head[p])head[p]=edge[id].nxt; if(~edge[id].nxt)edge[edge[id].nxt].pre=edge[id].pre; if(~edge[id].pre)edge[edge[id].pre].nxt=edge[id].nxt; &#125;&#125;E1,E2;/////////////////////////////////////////////////////////int n,m,s,A,B;/////////////////////////////////////////////////////////int dis[N];queue&lt;int&gt;Q;void BFS()&#123; while(!Q.empty())Q.pop(); memset(dis,-1,sizeof(dis)); dis[s]=0;Q.push(s); while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(int i=E1.head[p];~i;i=E1.edge[i].nxt)&#123; int to=E1.edge[i].to; if(dis[to]==-1)dis[to]=dis[p]+1,Q.push(to); &#125; &#125;&#125;/////////////////////////////////////////////////////////int dis1[N];bool mark[N];void BFS1()&#123; while(!Q.empty())Q.pop(); memset(dis1,-1,sizeof(dis1)); memset(mark,0,sizeof(mark)); dis1[s]=0;mark[s]=true;Q.push(s); while(!Q.empty())&#123; int p=Q.front();Q.pop(); for(int i=E1.head[p];~i;i=E1.edge[i].nxt)&#123; int to=E1.edge[i].to; mark[to]=true; &#125; for(int i=E1.head[p];~i;i=E1.edge[i].nxt)&#123; int pp=E1.edge[i].to; for(int j=E2.head[pp];~j;j=E2.edge[j].nxt)&#123; int to=E2.edge[j].to; if(!mark[to]&amp;&amp;dis1[to]==-1)&#123; dis1[to]=dis1[p]+2; mark[to]=true; Q.push(to); E2.del_edge(pp,j); &#125; &#125; &#125; for(int i=E1.head[p];~i;i=E1.edge[i].nxt)&#123; int to=E1.edge[i].to; mark[to]=false; &#125; &#125;&#125;int main()&#123; memset(E1.head,-1,sizeof(E1.head)); memset(E2.head,-1,sizeof(E2.head)); Rd(n),Rd(m),Rd(s),Rd(A),Rd(B); for(int i=1,a,b;i&lt;=m;i++)&#123; Rd(a),Rd(b); E1.add_edge(a,b); E1.add_edge(b,a); E2.add_edge(a,b); E2.add_edge(b,a); &#125; BFS(); BFS1(); for(int i=1;i&lt;=n;i++)&#123; int res=1&lt;&lt;30; if(~dis[i])res=min(dis[i]/2*B+dis[i]%2*A,dis[i]*A); if(~dis1[i])res=min(res,dis1[i]/2*B); printf(\"%d\\n\",res); &#125; return 0;&#125;","categories":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"https://YummyJay.github.io/tags/最短路/"},{"name":"双向链表","slug":"双向链表","permalink":"https://YummyJay.github.io/tags/双向链表/"}],"keywords":[{"name":"POI","slug":"POI","permalink":"https://YummyJay.github.io/categories/POI/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-10-08T12:00:00.000Z","updated":"2016-10-09T02:32:56.822Z","comments":true,"path":"2016/10/08/hello-world/","link":"","permalink":"https://YummyJay.github.io/2016/10/08/hello-world/","excerpt":"Hello World","text":"Hello World其实并不会搭博客，但在机房大神的帮助下还是搭了人生第一个博客。蛮喜欢这个主题，希望能够一直写下去。先来一发代码高亮：12345#include&lt;cstdio&gt;int main()&#123; puts(\"Hello World\"); return 0;&#125; Markdown其实也并不怎么会用，一边学一边写吧。","categories":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/categories/杂/"}],"tags":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/tags/杂/"}],"keywords":[{"name":"杂","slug":"杂","permalink":"https://YummyJay.github.io/categories/杂/"}]}]}